<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="simple-addons"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:ns5="http://www.w3.org/1999/xhtml"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Simple Add-Ons</title>

  <para><sidebar>
      <title>Pretty Good Privacy in Spring Roo</title>

      <para>The introduction of <link
      xlink:href="http://en.wikipedia.org/wiki/Pretty_Good_Privacy">PGP</link>
      with Spring Roo 1.1 allows the Roo user to indicate exactly which
      developers he trusts to sign software that Roo will download and
      activate in the Roo Shell. Roo itself is now also <link
      xlink:href="http://en.wikipedia.org/wiki/Pretty_Good_Privacy">PGP</link>
      signed in every release. To support these capabilities, a new protocol
      handler called <code>httppgp://</code> has been introduced into Roo. This
      tells Roo that a given HTTP URL also has a PGP armour detached signature
      available. By requiring PGP signatures for all add-ons, we're able to
      conveniently and safely host all Roo add-ons for the community. It's up
      to the user to decide if he trusts a given PGP key, and without trusting
      that key, Roo will refuse to even spend time downloading the
      <code>httppgp://</code> resource. Roo's approach also means you can use
      standalone PGP tools like GnuPG to perform signature-related operations to
      independently verify Roo's correct operation.</para>
    </sidebar>This chapter will provide an introduction to Spring Roo add-on
  development. The intention is to provide a step-by-step guide that walks the
  developer from zero code to a fully deployed and published add-on that
  is immediately available to all Spring Roo users. With the release of Spring
  Roo 1.1, a new set of commands is available that are designed to provide a
  fast introduction to add-on development, as well as easy access to registered
  add-ons by Spring Roo 1.1 users.</para>

  <para><sidebar>
      <title>OSGi in Spring Roo</title>

      <para>Spring Roo runs in an <link
      xlink:href="http://en.wikipedia.org/wiki/OSGi">OSGi</link> container
      since version 1.1. This internal change is ideal for Roo’s add-on model
      because it allows Roo users to install, uninstall, start, and stop
      different add-ons dynamically without restarting the Roo shell.
      Furthermore, <link
      xlink:href="http://en.wikipedia.org/wiki/OSGi">OSGi</link> allows
      automatic provisioning of external add-on repositories and provides very
      good infrastructure for developing modular, as well as embedded, and
      service-oriented applications. Under the hood, Spring Roo uses the <link
      xlink:href="http://felix.apache.org/site/index.html">Apache Felix</link>
      OSGi implementation.</para>
    </sidebar>A new add-on named 'Add-On Creator' has been developed that
  facilitates the creation of a new Spring Roo add-on. Furthermore, it offers
  out of the box support for the
  <link xlink:href="http://subversion.apache.org/">Subversion</link> integration
  provided by <link xlink:href="http://code.google.com/">Google Code</link> as
  well as zero setup for hosting the add-on in a public Maven repository hosted
  as part of a <link xlink:href="http://code.google.com/">Google Code</link>
  project. In order to register the add-on with RooBot - a Spring Roo add-on
  registration service - the add-on is also required to be <link
  xlink:href="http://en.wikipedia.org/wiki/OSGi">OSGi</link> compliant, needs
  to be signed with PgP keys and the addon bundle needs to be registered
  through the httppgp protocol. Add-on developers get all these features
  automatically configured if they use the new 'Add-On Creator' feature that
  ships with Spring Roo 1.1.</para>

  <para>The following sections will present a complete step-by-step guide
  demonstrating how to bootstrap a new Spring Roo add-on, publish and release it
  as your own Google Code project, and register it with the RooBot service.
  </para>

  <section>
    <title>Project Setup</title>

    <para>In addition to the general installation steps discussed in the
    development process chapter (section 4), you should also follow the
    following project specific steps:</para>

    <orderedlist>
      <listitem>
        <para>Create a new project in <link xlink:href="???">Google
        Code</link>: Sign in with your Google Account and navigate to <link
        xlink:href="http://code.google.com/hosting/createProject">http://code.google.com/hosting/createProject</link>
        where you can create your project:</para>

        <itemizedlist>
          <listitem>
            <para>Project Name - a meaningful name such as
            spring-roo-addon-mvc-i18n-french</para>
          </listitem>

          <listitem>
            <para>Project Summary - a summary of your project such as 'Spring
            Roo Add-On to provide French translation for Spring MVC
            scaffolding'</para>
          </listitem>

          <listitem>
            <para>Project Description - description that could include a
            version compatibility matrix for your add-on</para>
          </listitem>

          <listitem>
            <para>Version control system - Subversion</para>
          </listitem>

          <listitem>
            <para>Source code license - GNU General Public License v3</para>
          </listitem>

          <listitem>
            <para>Project Labels - Spring Roo, Java, Add-On</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>By default, SVN hosting in Google Code will give you a trunk,
        tags, branches and a wiki folder. In order to host a Maven repository
        in your Google code project, you should also create a repo folder as
        root for the new repository:<programlisting>$ <emphasis role="bold">svn mkdir</emphasis> -m "create maven repository" https://&lt;project-name&gt;.googlecode.com/svn/repo --username &lt;username&gt; --password &lt;password&gt;</programlisting></para>
      </listitem>

      <listitem>
        <para>Check out your newly created project from SVN:<programlisting>$ <emphasis
              role="bold">svn checkout</emphasis> https://&lt;project-name&gt;.googlecode.com/svn/trunk/ &lt;project-name&gt; --username &lt;username&gt;</programlisting></para>
      </listitem>

      <listitem>
        <para>(optional) Enter your Google Code SVN credentials into your
        local maven repository settings.xml:<programlisting>&lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt;
  &lt;servers&gt;
    &lt;server&gt;
      &lt;id&gt;<emphasis role="bold">Google Code</emphasis>&lt;/id&gt;
      &lt;username&gt;myusername&lt;/username&gt;
      &lt;password&gt;mypassword&lt;/password&gt;
    &lt;/server&gt;
  &lt;/servers&gt;
&lt;/settings&gt;</programlisting></para>
      </listitem>
    </orderedlist>
  </section>

  <section xml:id="simple-addons-fast-creation">
    <title>Fast Creation</title>

    <para><sidebar>
        <title>Roo's Add-On Creator Commands</title>

        <para>With release 1.1, Spring Roo offers the following commands to help
        developers quickly create new add-ons:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis role="bold">addon create simple</emphasis></para>

            <itemizedlist>
              <listitem>
                <para><emphasis>What</emphasis>: Command &amp; Operations
                support</para>
              </listitem>

              <listitem>
                <para><emphasis>When</emphasis>: Simple add-ons that want to
                add dependencies and/or configuration artifacts to a project
                </para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para><emphasis role="bold">addon create
            advanced</emphasis></para>

            <itemizedlist>
              <listitem>
                <para><emphasis>What</emphasis>: Command, Operations &amp; ITD
                support</para>
              </listitem>

              <listitem>
                <para><emphasis>When</emphasis>: Full-fledged add-ons that
                offer new functionality to project enhancements to existing
                Java types in project introduction of new Java types (+
                ITDs)</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para><emphasis role="bold">addon create i18n</emphasis></para>

            <itemizedlist>
              <listitem>
                <para><emphasis>What</emphasis>: Extension to the existing
                ‘web mvc install language’ command</para>
              </listitem>

              <listitem>
                <para><emphasis>When</emphasis>: A new translation is added to
                the Spring MVC admin UI scaffolding</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para><emphasis role="bold">addon create
            wrapper</emphasis><itemizedlist>
                <listitem>
                  <para><emphasis>What</emphasis>: Wrapping of a Maven
                  artifact with an OSGi compliant manifest</para>
                </listitem>

                <listitem>
                  <para><emphasis>When</emphasis>: A dependency is needed to
                  complete other functionality offered by a Roo add-on (for
                  example a JDBC driver for the DBRE add-on)</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </itemizedlist>
      </sidebar>Once you have installed Java, Maven, PGP, and SVN tools, and have
    created and checked out your Google Code project, you can change into the
    &lt;project-name&gt; directory, which at this stage should contain only the
    .svn directory. In the &lt;project-name&gt; directory, you can
    start the Spring Roo shell and use one of the new commands for add-on
    creation:<programlisting>roo&gt; addon create simple --topLevelPackage com.foo --projectName &lt;project-name&gt;</programlisting></para>

    <para>The <link linkend="command-index-addon-create-simple">addon create
    simple</link> command will scaffold a number of artefacts:</para>

    <para><programlisting>[1] pom.xml
[2] readme.txt
[3] legal/LICENSE.TXT
[4] src/main/java/com/foo/batch/BatchCommands.java
[5] src/main/java/com/foo/batch/BatchOperations.java
[5] src/main/java/com/foo/batch/BatchOperationsImpl.java
[6] src/main/java/com/foo/batch/BatchPropertyName.java
[7] src/main/assembly/assembly.xml</programlisting>This newly created add-on
    project can be imported into the SpringSource Tool Suite via File &gt;
    Import &gt; Maven &gt; Existing Maven projects. Let's discuss some of these
    artefacts in more detail:</para>

    <orderedlist>
      <listitem>
        <para><emphasis role="bold">pom.xml</emphasis> - This is the Maven
        project configuration. This configuration ships with a number of
        preinstalled Maven plugins that facilitate the PGP artefact
        signing process as well as the project release process (including
        tagging etc). It also adds the OSGi and Felix dependencies needed
        for the addon to run in the Roo Shell. Furthermore,
        several commonly used Spring Roo modules are preinstalled. These
        modules provide functionalities such as file system monitoring, Roo
        shell command registration, etc. More information about these
        functionalities is provided in the following sections.</para>

        <para>The add-on developer should open up the pom.xml file and modify
        some project specific references and documentation (marked in bold
        font):</para>

        <para><programlisting>&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;project [...]&gt;
  [...]
  &lt;name&gt;<emphasis role="bold">com-foo-batch</emphasis>&lt;/name&gt;
  &lt;organization&gt;
    &lt;name&gt;<emphasis role="bold">Your project/company name goes here (used in copyright and vendor information in the manifest)</emphasis>&lt;/name&gt;
  &lt;/organization&gt;
  [...]
  &lt;description&gt;<emphasis role="bold">An add-on created by Spring Roo's addon creator feature.</emphasis>&lt;/description&gt;
  &lt;url&gt;<emphasis role="bold">http://www.some.company</emphasis>&lt;/url&gt;
  &lt;properties&gt;</programlisting>Some of these properties can also be
        provided when issuing the <link
        linkend="command-index-creator-commands">addon create</link>
        command.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">readme.txt</emphasis> - You can provide
        any setup or installation information about your add-on in this file.
        This file is used by other developers who checkout your add-on source
        code from the SVN repository.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">legal/LICENSE.TXT</emphasis> - Copy the
        appropriate license text for your add-on into this file.</para>
      </listitem>

      <listitem>
        <para><emphasis
        role="bold">src/main/java/com/foo/batch/BatchCommands.java</emphasis>
        - This is a fully working code example demonstrating how to register
        commands offered by your addon into the Spring Roo Shell (more detailed
        information in the next section).</para>
      </listitem>

      <listitem>
        <para><emphasis
        role="bold">src/main/java/com/foo/batch/BatchOperations.java &amp;
        BatchOperationsImpl.java</emphasis> - These artefacts are used to
        perform operations triggered by a command (more information in the
        next sections).</para>
      </listitem>

      <listitem>
        <para><emphasis
        role="bold">src/main/java/com/foo/batch/BatchPropertyName.java</emphasis>
        - This type provides a simple example demonstrating the use of static
        command completion options for the Spring Roo Shell. An example of
        static command completion options are for example the database selection
        options as part of the <link
        linkend="command-index-jpa-setup">jpa setup</link>
        command.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">src/main/assembly/assembly.xml</emphasis>
        - This artefact defines configurations used for the packaging of the
        add-on.</para>
      </listitem>
    </orderedlist>
  </section>

  <section xml:id="simple-addons-shell-interaction">
    <title>Shell Interaction</title>

    <para>Spring Roo provides an easy way for external add-ons to contribute
    new commands to the Roo Shell. Looking at the code extract below, there
    are really only two artefacts needed in your command type to register a
    new command in the Roo Shell; your type needs to implement the <emphasis
    role="bold">CommandMarker</emphasis> interface, and you need to create a
    method annotated with <emphasis role="bold">@CliCommand</emphasis>. Let us
    review some details:</para>

    <para><programlisting>[1] <emphasis role="bold">@Component</emphasis>
[1] <emphasis role="bold">@Service</emphasis>
[2] public class BatchCommands implements <emphasis role="bold">CommandMarker</emphasis> {

[3]    <emphasis role="bold">@Reference</emphasis> private BatchOperations operations;
       <emphasis role="bold">@Reference</emphasis> private StaticFieldConverter staticFieldConverter;

[4]    protected void <emphasis role="bold">activate</emphasis>(ComponentContext context) {
          staticFieldConverter.add(BatchPropertyName.class);
       }

[4]    protected void <emphasis role="bold">deactivate</emphasis>(ComponentContext context) {
          staticFieldConverter.remove(BatchPropertyName.class);
       }

[5]   <emphasis role="bold"> @CliAvailabilityIndicator</emphasis>("welcome property")
       public boolean isPropertyAvailable() {
          return operations.isProjectAvailable();  
       }

[6]   <emphasis role="bold"> @CliCommand</emphasis>(value="welcome property", help="Obtains a pre-defined system property")
[7]    public String property(<emphasis role="bold">@CliOption</emphasis>(key="name", mandatory=false, specifiedDefaultValue="USERNAME", unspecifiedDefaultValue="USERNAME", help="The property name you'd like to display") BatchPropertyName propertyName) {
          return operations.getProperty(propertyName);
       }</programlisting>There are a few artefacts of interest when developing
    Spring Roo add-ons:</para>

    <orderedlist>
      <listitem>
        <para>To register components and services in the Roo shell, the type
        needs to be annotated with the <emphasis
        role="bold">@Component</emphasis> &amp; <emphasis
        role="bold">@Service</emphasis> annotations provided by Felix. These
        components can be injected into other add-ons (more interesting for
        functionalities exposed by operations types).</para>
      </listitem>

      <listitem>
        <para>The command type needs to implement the <emphasis
        role="bold">CommandMarker</emphasis> interface, which Spring Roo scans
        for in order to detect classes that contribute commands to the Roo
        Shell.</para>
      </listitem>

      <listitem>
        <para>The Felix <emphasis role="bold">@Reference</emphasis>
        annotations are used to inject services and components offered by
        other Spring Roo core components or even other add-ons. In this
        example, we are injecting a reference to the add-on's own
        BatchOperations interface and the StaticFieldConverter component offered
        by the Roo Shell OSGi bundle. The Felix <emphasis
        role="bold">@Reference</emphasis> annotation is similar in purpose to
        Spring's @Autowired and @Inject annotations.</para>
      </listitem>

      <listitem>
        <para>The <emphasis role="bold">activate</emphasis> and <emphasis
        role="bold">deactivate</emphasis> methods can optionally be
        implemented to get access to the lifecycle of the addon's bundle as
        managed by the underlying OSGi container. Roo add-on developers can use
        these lifecycle hooks for registration and deregistration of converters
        (typically in command types) or for the registration of metadata
        dependencies (typically in ITD-providing add-ons) or any other component
        initialization activities.</para>
      </listitem>

      <listitem>
        <para>The optional <emphasis role="bold">@CliAvailabilityIndicator</emphasis>
        annotation allows you to limit when a command is available in the
        Spring Roo Shell. Methods thus annotated should return a boolean to
        indicate whether a command should be visible to the Roo Shell. For
        example, many commands are hidden before a project has been created.</para>
      </listitem>

      <listitem>
        <para>The <emphasis role="bold">@CliCommand</emphasis> annotation
        plays a central role for Roo add-on developers. It allows the
        registration of new commands for the Roo Shell. Methods annotated with
        <emphasis role="bold">@CliCommand</emphasis> can optionally return a
        String value to contribute a log statement to the Spring Roo Shell.
        Another, more flexible, option to provide log statements in the Roo
        Shell is to register a standard JDK logger, which allows the developer
        to present color-coded messages to the user in the Roo shell, with the
        color coding being dependent on the log level (warning, info, error,
        etc).</para>
      </listitem>

      <listitem>
        <para>The optional <emphasis role="bold">@CliOption</emphasis>
        annotation can be used to annotate method parameters. These parameters
        define command attributes that are presented as part of a command.
        Roo will attempt to automatically convert user-entered values into the
        Java type of the annotated method parameter. In the example above,
        Roo will convert the user-entered String to a BatchPropertyName. By
        default, Roo offers converters for common number types, String, Date,
        Enum, Locale, boolean and Character. See the
        <emphasis>org.springframework.roo.shell.converters</emphasis> package
        for examples if you need to implement a custom converter.</para>
      </listitem>
    </orderedlist>
  </section>

  <section xml:id="simple-addons-operations">
    <title>Operations</title>

    <para>Almost all Spring Roo add-ons provide operations types. These types
    do most of the work behind Roo's passive generation principle (active
    generation is taken care of by AspectJ Intertype declarations (ITDs) -
    more about that later). Methods offered by the operations types provided
    by the add-on are typically invoked by the accompanying "command" type.
    Alternatively, operations types can also be invoked by other add-ons (this
    is a rather unusual case).</para>

    <para>Implementations of the Operations interface need to be annotated
    with the Felix <emphasis role="bold">@Component</emphasis> and <emphasis
    role="bold">@Service</emphasis> annotations to make their functionality
    available within Roo's OSGi container. Dependencies can be injected into
    operations types via the Felix <emphasis role="bold">@Reference</emphasis>
    annotation. If the dependency exists in a package that is not yet
    registered in the add-on's pom.xml, you need to add the dependency there
    to add the relevant bundle to the add-on's classpath.</para>

    <para>The Add-On Creator generated project includes example code which
    uses Roo's source path abstractions, file manager and various Util classes
    that take care of project file management.</para>

    <para>Typical functionality offered by operations types include:</para>

    <itemizedlist>
      <listitem>
        <para>Adding new dependencies, plugins, &amp; repositories to the
        Maven project pom.xml.</para>
      </listitem>

      <listitem>
        <para>Copying static artefacts from the add-on jar into the user
        project (i.e. CSS, images, tagx, configuration files, etc).</para>
      </listitem>

      <listitem>
        <para>Configuring application contexts, web.xml, and other config
        artefacts.</para>
      </listitem>

      <listitem>
        <para>Managing properties files in the user project.</para>
      </listitem>

      <listitem>
        <para>Creating new Java source types in the user project.</para>
      </listitem>

      <listitem>
        <para>Adding trigger (or other) annotations to target types (most
        common), fields or methods.</para>
      </listitem>
    </itemizedlist>

    <para>Spring Roo offers a wide range of abstractions and metadata types
    that support these use cases. For example, the following services are
    offered:</para>

    <itemizedlist>
      <listitem>
        <para>org.springframework.roo.process.manager.<emphasis
        role="bold">FileManager</emphasis></para>

        <itemizedlist>
          <listitem>
            <para>use file manager for all file system operations in project
            (offers automatic undo on exception)</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>org.springframework.roo.project.<emphasis
        role="bold">PathResolver</emphasis></para>

        <itemizedlist>
          <listitem>
            <para>offers abstraction over common project paths</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>org.springframework.roo.metadata.<emphasis
        role="bold">MetadataService</emphasis></para>

        <itemizedlist>
          <listitem>
            <para>offers access to Roo metadata bean info metadata for
            mutators/accessors of target type</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>org.springframework.roo.project.<emphasis
        role="bold">ProjectMetadata</emphasis></para>

        <itemizedlist>
          <listitem>
            <para>project name, top level package read access to project
            dependencies, repositories, etc</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>org.springframework.roo.project.<emphasis
        role="bold">ProjectOperations</emphasis></para>

        <itemizedlist>
          <listitem>
            <para>add, remove project Maven dependencies, plugins,
            repositories, filters, properties, etc</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>

    <para></para>

    <para>In addition the org.springframework.roo.support bundle provides a
    number of useful utils classes:</para>

    <itemizedlist>
      <listitem>
        <para>org.springframework.roo.support.util.<emphasis
        role="bold">Assert </emphasis></para>

        <itemizedlist>
          <listitem>
            <para>similar to Spring’s Assert, exceptions thrown by Assert will
            cause Roo's File manager abstraction to roll back.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>org.springframework.roo.support.util.<emphasis
        role="bold">FileCopyUtils</emphasis></para>

        <itemizedlist>
          <listitem>
            <para>useful for copying resources from add-on into project</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>org.springframework.roo.support.util.<emphasis
        role="bold">TemplateUtils</emphasis></para>

        <itemizedlist>
          <listitem>
            <para>useful for obtaining InputStream of resources in
            bundle</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>org.springframework.roo.support.util.<emphasis
        role="bold">XmlUtils</emphasis></para>

        <itemizedlist>
          <listitem>
            <para>hides XML ugliness</para>

            <itemizedlist>
              <listitem>
                <para>writeXml methods</para>
              </listitem>

              <listitem>
                <para>Xpath abstraction &amp; cache</para>
              </listitem>

              <listitem>
                <para>XML Transformer setup</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
  </section>

  <section xml:id="simple-addons-packaging">
    <title>Packaging &amp; Distribution</title>

    <para>Once your add-on is complete, you can test its functionality locally
    by generating an OSGi-compliant jar bundle and installing it in the Spring
    Roo Shell:</para>

    <para><programlisting>&lt;project-name&gt;$ <emphasis role="bold">mvn clean install</emphasis></programlisting>This
    will generate your add-on OSGi bundle in the project's
    <emphasis>target</emphasis> directory. In a separate directory, you can
    start the Spring Roo Shell and use the following command to test your new
    add-on:</para>

    <para><programlisting>roo&gt; <emphasis role="bold">osgi start</emphasis> --url file:///&lt;path-to-addon-project/target/&lt;addon-bundle-name&gt;.&lt;version&gt;.jar</programlisting>This
    should install and activate your new Spring Roo Add-On. For troubleshooting,
    Roo offers the following OSGi commands:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold"><link linkend="command-index-osgi-ps">osgi
        ps</link> </emphasis>- Displays OSGi bundle information &amp; status.
        This should list your add-on as active.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold"><link
        linkend="command-index-osgi-log">osgi log</link></emphasis> - Access
        OSGi container logs. This could identify possible issues occurring
        during add-on activation.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold"><link
        linkend="command-index-osgi-scr-list">osgi scr list</link>
        </emphasis>- Lists all currently registered services and components.
        This should list your add-on's command, metadata provider, and
        operations types.</para>
      </listitem>

      <listitem>
        <para><link linkend="command-index-osgi-scr-info"><emphasis
        role="bold">osgi scr info</emphasis></link> - Info about a specific
        component. This can be used to identify possible unresolved
        dependencies.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold"><link
        linkend="command-index-osgi-start">osgi start</link></emphasis> -
        install a new add-on directly from a local or remote location.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">help osgi</emphasis> - Help on Roo's ~20
        osgi commands.</para>
      </listitem>
    </itemizedlist>

    <para>Once you have tested the add-on successfully in your development
    environment, you can release the add-on source code to your Google Code
    project, create a tag, and install all relevant artifacts in the project's
    Maven repository:</para>

    <para><programlisting>&lt;project-name&gt;$ <emphasis role="bold">svn add pom.xml src/ legal/ readme.txt</emphasis>

&lt;project-name&gt;$ <emphasis role="bold">svn commit</emphasis> -m "initial commit"

&lt;project-name&gt;$ <emphasis role="bold">mvn release:prepare release:perform </emphasis></programlisting>The
    Maven release plugin will ask for tag and release artefact names. Roo
    follows the OSGi convention of using the major, minor and micro version
    numbers followed by a textual identifier, e.g. 0.1.1.RELEASE,
    0.1.2.BUILD-SNAPSHOT, etc.</para>

    <para>Deployment for bundles created with Roo's "wrapping" command can be
    deployed rather than released. For example, to create a wrapped bundle of
    the PostgreSQL JDBC driver, use this command:<programlisting>roo&gt; <emphasis
          role="bold">addon create wrapper</emphasis> --topLevelPackage com.foo.wrapper --projectName spring-roo-postgres-wrapper --artifactId postgresql \
--groupId postgresql --version 9.0-801.jdbc3 --description "Postgres #jdbcdriver driverclass:org.postgresql.Driver." \
--licenseUrl http://jdbc.postgresql.org/license.html --docUrl http://jdbc.postgresql.org/ --vendorName "The PostgreSQL Global Development Group"</programlisting></para>

    <para>This can then be deployed to a Google code project (set up in the
    same way as described above) with a simple deploy command:</para>

    <para><programlisting>&lt;project-name&gt;$ <emphasis role="bold">mvn deploy</emphasis></programlisting></para>
  </section>

  <section>
    <title>Publishing to RooBot</title>

    <para>Once the release is complete, check your Google Code project to see
    that your add-on's pom.xml has been updated to the new version (e.g.
    0.1.2.BUILD-SNAPSHOT), that a new tag has been committed to the
    <emphasis>tags</emphasis> directory, and that the <emphasis>repo</emphasis>
    directory has been populated with all the artifacts seen in a typical
    Maven repository. All artefacts have been signed with your private PGP key,
    and your public key is available in the relevant <emphasis>.asc</emphasis>
    files. In the repo directory, you should also find the
    <emphasis>repository.xml</emphasis> file which contains all relevant
    information for an OSGi OBR repository.</para>

    <para><sidebar>
        <title>Raw URLs in Google Code Source Browser</title>

        <para>When reviewing file contents via the HTTP interface provided by
        Google Code, the reader is presented with HTML documents (which
        provide syntax highlighting, etc). To get access to the real (raw) URL
        of a document (e.g. repo/repository.xml) you need to click the 'View raw
        file' link found in the 'File info' section in the right-hand menu.
        Example of a raw URL:
        http://&lt;project-name&gt;.googlecode.com/svn/repo/repository.xml.
        Make sure the version appendix is <emphasis
        role="bold">removed</emphasis> from the URL before clicking the
        'View raw file' link (i.e.
        http://&lt;project-name&gt;.googlecode.com/svn/repo/repository.xml<emphasis
        role="bold">?r=25)</emphasis></para>
      </sidebar>The URL to the raw (see sidebar) repository.xml artefact can
    then be registered with <link
    xlink:href="mailto:s2-roobot@vmware.com">RooBot</link>:</para>

    <para>Register your new add-on repository by sending an email to <link
    xlink:href="mailto:s2-roobot@vmware.com">s2-roobot@vmware.com</link> where
    the subject line MUST be the raw URL to OSGi repository.xml. The email
    body is not currently used (but you can send greetings to the Roo team
    ;-). Other registration methods are being considered (web front-end, Roo
    shell command, etc).</para>

    <para>RooBot verifies a few aspects before publishing your new add-on to
    the community:</para>

    <itemizedlist>
      <listitem>
        <para>The provided repository.xml must be a valid OSGi
        repository</para>
      </listitem>

      <listitem>
        <para>The resource URI must use the httppgp prefix i.e.: &lt;resource
        uri="httppgp://fr-test.googlecode.com/svn/…/&gt;</para>
      </listitem>

      <listitem>
        <para>The bundle referenced in the repository has a corresponding .asc
        file containing the PgP public key</para>
      </listitem>

      <listitem>
        <para>The public PGP key of the add-on signer needs to be available at
        <link
        xlink:href="http://keyserver.ubuntu.com/">http://keyserver.ubuntu.com/</link>
        A guide to PGP key management can be found <link
        xlink:href="https://help.ubuntu.com/community/GnuPrivacyGuardHowto">here</link>.
        Make sure to publish your key with this command:</para>

        <programlisting>gpg --send-keys --keyserver keyserver.ubuntu.com &lt;your-key-id&gt;</programlisting>
      </listitem>

      <listitem>
        <para>RooBot will retrieve publicly accessible key information (key
        owner name, email) from public key server</para>
      </listitem>

      <listitem>
        <para>The referenced bundle contains an OSGi-compliant manifest.mf
        file. For example, it will verify that the add-on version defined in
        your repository.xml matches the version defined in the manifest of
        your add-on.</para>
      </listitem>

      <listitem>
        <para>[Important] To ensure your repository is valid, RooBot will
        download all defined resources in the repository. To do that, it will
        read the uri attribute and perform an HTTP GET request against the
        defined URL (after replacing the httppgp:// protocol handler with
        http://). Should the download or verification of any of the defined
        resources in the respository fail, RooBot will abort the processing of
        the entire repository and try again later.</para>
      </listitem>
    </itemizedlist>

    <para>If all tests pass, RooBot will publish your add-on in a publicly
    accessible XML registry <link
    xlink:href="http://spring-roo-repository.springsource.org/roobot/roobot.xml">http://spring-roo-repository.springsource.org/roobot/roobot.xml</link>.
    This registry is available to the RooBot client integrated into the Spring
    Roo Shell.</para>

    <para>Once you have sent your email to <link
    xlink:href="mailto:s2-roobot@vmware.com">s2-roobot@vmware.com</link>, you
    should receive a response from RooBot indicating that the processing of
    your repository has started. If successful, you will see your add-on
    listed at <link
    xlink:href="http://spring-roo-repository.springsource.org/roobot/roobot.xml">http://spring-roo-repository.springsource.org/roobot/roobot.xml</link>
    within a few hours. If this does not happen, you can visit the RooBot
    error log at <link
    xlink:href="http://spring-roo-repository.springsource.org/roobot/roobot-log.txt">http://spring-roo-repository.springsource.org/roobot/roobot-log.txt</link>,
    which is refreshed every 5 minutes.</para>

    <para>Once RooBot has published your add-on sucessfully, it will
    periodically process your repository to verify its ongoing validity. As
    part of this periodic processing, it will also automatically pick up new
    versions (add-on releases) in your repository.xml. Therefore it should not
    be necessary to explicitly notify RooBot of any changes in your
    repository.</para>
  </section>

  <section>
    <title>Upgrading Spring Roo Add-Ons from 1.0.x to 1.1.0</title>

    <para>As OSGi is the runtime platform for Roo 1.1.0 onwards, porting addons
    from a previous version will require some small tweaks to your code. Here's
    a step-by-step guide on what you need to do:</para>

    <orderedlist>
      <listitem>
        <para>Change packaging of your project to bundle</para>

        <para>As your plugin will result in an OSGi bundle, you need to change
        the packaging from <code>jar</code> to <code>bundle</code>. This will
        cause the Maven bundle plugin to create the necessary metadata for you
        out of the box.</para>
      </listitem>

      <listitem>
        <para>Change the type of the dependencies to bundle</para>

        <para>Similar to the point above, you need to reference dependencies as
        bundles. Again, let the Maven bundle plugin do its job.</para>
      </listitem>

      <listitem>
        <para>Sync the build section of your pom with the one provided in the
        addon template</para>

        <para>Compare your add-on's original <filename>pom.xml</filename> with a
        pom.xml generated by the <link
        linkend="command-index-addon-create-simple">addon create</link>
        command (see below). This is mostly related to the Maven bundle plugin
        as well as the Maven SCR plugin (see next point for details).</para>

        <example>
          <title>Creating a Roo addon project</title>

          <programlisting>addon create simple --topLevelPackage com.mycompany.myproject.roo.addon</programlisting>

          <para>The easiest way to do so is simply creating a dummy addon
          project using the template and copying the plugin configuration into
          your pom.</para>
        </example>
      </listitem>

      <listitem>
        <para>Replace @ScopeDevelopment annotations with @Component and
        @Service</para>

        <para>Roo uses Apache Felix as OSGi runtime and thus uses
        <interfacename>@Component</interfacename> and
        <interfacename>@Service</interfacename> annotations in combination
        with the Maven SCR plugin<footnote>
            <para>for details see <link
            xlink:href="http://felix.apache.org/site/apache-felix-maven-scr-plugin.html">http://felix.apache.org/site/apache-felix-maven-scr-plugin.html</link></para>
          </footnote> to create descriptors for the OSGi declarative services
        infrastructure.</para>

        <example>
          <title>Component declaration with Apache Felix annotations</title>

          <programlisting language="java"><emphasis role="bold">@Service
</emphasis><emphasis role="bold">@Component</emphasis>
public class MyCommands implements <emphasis role="bold">CommandMarker</emphasis> {

  <emphasis role="bold">@Reference </emphasis>MyOperations operations;

  // Your code goes here
}</programlisting>

          <para>So every <interfacename>@ScopeDevelopment</interfacename>
          annotation you used in your command and operations classes has to be
          replaced by <interfacename>@Service</interfacename> and
          <interfacename>@Component</interfacename>. If you had injected other
          services into your command or operations class, you can use
          <interfacename>@Reference</interfacename> to wire them into your
          component instance. Note that your class will have to implement at
          least one interface under which Felix can publish the component
          instance. Check the output of the Maven SCR plugin for errors to see
          whether any further tweaks are necessary.</para>
        </example>
      </listitem>
    </orderedlist>
  </section>
</chapter>

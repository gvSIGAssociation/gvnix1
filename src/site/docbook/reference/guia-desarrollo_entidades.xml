<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="guia-desarrollo_gestion-entidades"
         xml:lang="es" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/1998/Math/MathML"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title xml:lang="es">Gestión de entidades</title>

	<para>El acceso a datos de una aplicación contiene la infraestructura necesaria para obtener y
	almacenar la información en, por ejemplo, una base de datos.
	Este acceso se puede estructurar en una sola capa en la que las entidades definen tanto
	el modelo de los datos, como sus métodos de interacción con la base de datos y la lógica
	de negocio utilizando entonces un modelo llamado <emphasis>Registro Activo</emphasis>.
	Existen otros casos más clásicos como la estructuración en una capa de entidades, otra
	de acceso a datos (DAO) y una última de servicios con la lógica de negocio; todo ello
	llamado <emphasis>Servicios y Repositorios</emphasis>.
	Este capítulo se centrará en la generación de la capa de entidades ya que es el método
	que se utiliza habitualmente en las aplicaciones desarrolladas con gvNIX y para el cual
	ha añadido la mayoría de sus nuevas funcionalidades.
	</para>


  <para xml:lang="es">Las entidades del modelo del dominio son uno de los
  elementos más importantes del framework. En Java una entidad se corresponde con una clase,
  definida en un archivo <filename>.java</filename>.</para>

  <para>Además de la lógica de negocio, cada clase contiene una serie de
  anotaciones de clase y de atributos que forman parte de la metainformación
  que permite a gvNIX realizar acciones automáticas.</para>

  <example>
    <title>Una clase Java</title>

    <programlistingco>
      <areaspec>
        <area coords="1" xml:id="ex.annot.class"/>

        <area coords="7" xml:id="ex.annot.attri"/>
      </areaspec>

      <programlisting>
@RooJavaBean
@RooToString
@RooJpaActiveRecord
public class Entity1 {

        @Size(max = 20)
        @NotNull
        private String name;

        @Size(max = 20)
        private String apellidos;
}</programlisting>

      <calloutlist>
        <callout arearefs="ex.annot.class">
          <para>Anotación de clase</para>
        </callout>

        <callout arearefs="ex.annot.attri">
          <para>Anotación de atributo</para>
        </callout>
      </calloutlist>
    </programlistingco>
  </example>

  <para xml:lang="es">El framework añadirá todos los métodos estándar necesarios para
  completar la definición de entidad, como los de persistencia (almacenamiento
  y recuperación), gets/sets y métodos auxiliares como toString.
  Como se vió en la sección de generación de código se
  crearán una serie de archivos <filename>.aj</filename> que en tiempo de
  compilación se incluyen en la clase de forma transparente.</para>

  <para xml:lang="es">Si por algún motivo es necesario <emphasis>personalizar
  el comportamiento</emphasis> de alguno de los <emphasis>métodos estándar que
  se generan</emphasis>, simplemente hay que <emphasis>definirlos en la
  clase java</emphasis>. Cuando el framework detecta el cambio actualiza el
  fichero <filename>aj</filename> correspondiente para eliminar esta
  definición.</para>

  <para xml:lang="es">Existen dos formas de crear una entidad:</para>

  <orderedlist>
    <listitem>
      <para xml:lang="es">Usando el intérprete de comandos.</para>
    </listitem>

    <listitem>
      <para xml:lang="es">Usando el IDE de desarrollo.</para>
    </listitem>
  </orderedlist>

  <section xml:id="guia-desarrollo_gestion-entidades_definicion_crear-con-comando">
    <title xml:lang="es">Crear una entidad con el intérprete de
    comandos</title>

    <para xml:lang="es">Desde el intérprete de comandos se puede crear
    entidades de forma sencilla con los comandos: <command>entity jpa</command> y
    <command>field</command>.</para>

    <section xml:id="guia-desarrollo_gestion-entidades_definicion_crear-con-comando_entity">
      <title xml:lang="es">Comando entity jpa</title>

      <para xml:lang="es">Este comando crea una nueva entidad en el
      proyecto. Requiere como mínimo definir el parámetro
      <parameter>--class</parameter> para especificar el nombre y el paquete
      de la nueva clase. En este parámetro se puede utilizar el carácter
      <literal>~</literal> como abreviatura del paquete base del
      proyecto.</para>

      <para xml:lang="es">Entre los parámetros obligatorios se encuentran
      :</para>

      <variablelist>
        <varlistentry>
          <term xml:lang="es">--class</term>

          <listitem>
            <para xml:lang="es">Nombre de la clase java para la entidad
            (incluido su paquete) (recordar que se puede usar el
            <literal>~</literal> para especificar el paquete base de la
            aplicación).</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para xml:lang="es">Entre los principales parámetros opcionales
      (notar que hay más) se encuentran:</para>

      <variablelist>
        <varlistentry>
          <term xml:lang="es">--activeRecord</term>

          <listitem>
            <para xml:lang="es">Generar los métodos de creación,
            lectura, actualización y borrado (CRUD) para esta
            entidad. Esto implica el uso de un patrón de entidades
            del tipo registro activo.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">--entityName</term>

          <listitem>
            <para xml:lang="es">Nombre a usar para la
            entidad. Diferenciar del parámetro <emphasis>tabla
            </emphasis> que define el nombre de su tabla asociada.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">--identifierType</term>

          <listitem>
            <para xml:lang="es">Permite definir el tipo (clase java) de
            identificador (clave primaria) que usará esta entidad.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">--identifierField</term>

          <listitem>
            <para xml:lang="es">Nombre del <emphasis>campo en la
            entidad</emphasis> (no en BBDD) que se usará para el
            identificador.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">--identifierColumn</term>

          <listitem>
            <para xml:lang="es">Nombre de la <emphasis>columna de la
            BBDD</emphasis> donde almacenar el valor de clave primaria.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">--persistenceUnit</term>

          <listitem>
            <para xml:lang="es">Unidad de persistencia a utilizar
            para gestionar la interacción de la entidad con la
            base de datos. Como cada unidad de persistencia puede
            estar asociada a una base de datos distinta, es la forma
            de definir que una entidad se encuentra almacenada en
            otra base de datos.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">--schema</term>

          <listitem>
            <para xml:lang="es">Esquema de base de datos donde
            se encontrará la tabla asociada con la entidad.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">--table</term>

          <listitem>
            <para xml:lang="es">Nombre de la <emphasis>tabla de la
            BBDD</emphasis> donde almacenar los datos para esta
            entidad.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">--testAutomatically</term>

          <listitem>
            <para xml:lang="es">Genera los test unitarios para esta entidad
            usando JUnit.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">--versionColumn</term>

          <listitem>
            <para xml:lang="es">Nombre de la columna en base de datos
            que se comporta como campo de control de concurrencia
            optimista basado en número de versión.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">--versionType</term>

          <listitem>
            <para xml:lang="es">Tipo de la columna de base de datos
            que se comporta como campo de control de concurrencia
            optimista basado en número de versión.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para xml:lang="es">El resto de las opciones podemos verlas con el
      autocompletado del comando escribiendo <emphasis>--</emphasis>,
      en la documentación oficial de Roo o
      usando el comando <command>help entity</command>.</para>

      <important>
        <title xml:lang="es">Eliminar y modificar entidades</title>

        <para xml:lang="es">La consola no se utiliza para eliminar o modificar
        las entidades. Esto se debe realizar usando el IDE. Para más
        información ver la sección <link
        linkend="guia-desarrollo_gestion-entidades_definicion_modificar-modelo">Modificar
        una entidad</link>.</para>
      </important>
    </section>

    <section xml:id="guia-desarrollo_gestion-entidades_definicion_crear-con-comando_field">
      <title xml:lang="es">Comando field</title>

      <para xml:lang="es">No existe un comando <command>field</command>
      propiamente dicho, sino que es el nombre de un grupo de comandos que permiten
      añadir campos a una entidad. Los comandos finales se forman con el formato
      <command>field {tipo}</command> donde <parameter>{tipo}</parameter> es
      el tipo de dato que va almacenar. Así tenemos los siguientes:</para>

      <variablelist>
        <varlistentry>
          <term xml:lang="es">field string</term>

          <listitem xml:lang="es">
            <para>Crea un campo de tipo cadena
            alfanumérica.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">field boolean</term>

          <listitem xml:lang="es">
            <para>Crea un campo de tipo booleano
            (valores cierto o falso).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">field date</term>

          <listitem xml:lang="es">
            <para>Crea un campo de tipo fecha.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">field email template</term>

          <listitem xml:lang="es">
            <para>Crea un campo con una plantilla preparada para almacenar
            direcciones de correo electrónico.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">field embedded</term>

          <listitem xml:lang="es">
            <para>Añade un campo del tipo <emphasis>@Embedded</emphasis>
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">field enum</term>

          <listitem xml:lang="es">
            <para>Crea un campo de tipo enumerado. El tipo enumerado
            debe haber sido creado previamente con el comando
            <emphasis>enum type</emphasis>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">field file</term>

          <listitem xml:lang="es">
            <para>Crea un campo de tipo fichero.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">field number</term>

          <listitem xml:lang="es">
            <para>Crea un campo de tipo numérico (es posible especificarle el
            tipo mediante el parámetro <parameter>--type</parameter>).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">field reference</term>

          <listitem xml:lang="es">
            <para>Crea un campo que será una referencia a otra entidad.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">field set</term>

          <listitem xml:lang="es">
            <para>Crea un campo que devolverá una lista de elementos de una
            entidad relacionados con este elemento.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">field other</term>

          <listitem xml:lang="es">
            <para>Crea un campo de otro tipo no registrado.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Cada uno de estos comandos admiten bastantes parámetros que
      permiten definir múltiples comportamientos especiales, algunos aplicables a todos los comandos
      y otros específicos solo para algunos de ellos. Entre los generales que aplicar
      a la mayoría podemos encontrar los siguientes:</para>

      <variablelist>

        <varlistentry>
          <term>--class</term>

          <listitem>
            <para xml:lang="es">Clase entidad dondecrear el campo.
            Admite el uso de <literal>~</literal> para identificar al
            paquete base del proyecto y tiene autocompletado. No es
            necesario de especificar si acabamos de crear una entidad.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>--column</term>

          <listitem>
            <para xml:lang="es">Nombre de la columna en BBDD donde se
            almacenará el valor.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>--fieldName</term>

          <listitem>
            <para xml:lang="es">Nombre del campo que vamos a generar.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>--notNull y --nullRequired</term>

          <listitem>
            <para xml:lang="es">Especifica el comportamiento de campo ante
            los valores nulos.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>--regexp</term>

          <listitem>
            <para xml:lang="es">Permite definir una expresión regular
            que debe cumplir el valor que se establezca en este campo.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>--sizeMax y --sizeMin</term>

          <listitem>
            <para xml:lang="es">Limitaciones de tamaño.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>--transient</term>

          <listitem>
            <para xml:lang="es">Indica que el campo no tiene asociada
            ninguna columna en la base de datos, es decir, no se almacena
            ni obtiene de ella.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>--unique</term>

          <listitem>
            <para xml:lang="es">Indica que el campo tiene la restricción
            de unicidad para los valores que puede almacenar.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para xml:lang="es">Existen más opciones dependiendo del tipo de dato,
      para más información ver la ayuda de la consola o acceder a la documentación
      oficial de Roo en
      <link xlink:href="http://static.springsource.org/spring-roo/reference/html/">
      http://static.springsource.org/spring-roo/reference/html/</link></para>

      <important>
        <title xml:lang="es">Enlazar modelo de entidades con base de datos
        existente</title>

        <para xml:lang="es">Notar que el parámetro <command>--column</command>
        permiten que en tiempo de creación podemos indicar que la entidad sea
        persistente sobre un modelo relacional creado con anterioridad.</para>
      </important>

      <important>
        <title xml:lang="es">Eliminar y modificar campos</title>

        <para xml:lang="es">No se pueden eliminar o modificar los campos desde
        línea de comandos. Esto se debe realizar usando el IDE. Para más
        información ver la sección <link
        linkend="guia-desarrollo_gestion-entidades_definicion_modificar-modelo">Modificar
        una entidad</link>.</para>
      </important>
    </section>

    <section xml:id="guia-desarrollo_gestion-entidades_definicion_crear-con-comando_field_ejemplos">
      <title xml:lang="es">Proyecto ejemplo</title>

      <para xml:lang="es">Crear el modelo de dominio de la aplicación
      de venta de pizzas con la siguiente secuencia de comandos
      a partir del mismo ejemplo iniciado en capítulos anteriores:</para>

      <orderedlist>
        <listitem>
          <para xml:lang="es">Topping:</para>

          <programlisting>roo-gvNIX&gt; <command>entity jpa --class ~.domain.Topping --testAutomatically</command>
~.domain.Topping roo-gvNIX&gt; <command>field string --fieldName name --notNull --sizeMin 2</command>
                </programlisting>
        </listitem>

        <listitem>
          <para xml:lang="es">Base:</para>

          <programlisting>~.domain.Topping roo-gvNIX&gt; <command>entity jpa --class ~.domain.Base --testAutomatically</command>
~.domain.Base roo-gvNIX&gt; <command>field string --fieldName name --notNull --sizeMin 2</command>
                </programlisting>
        </listitem>

        <listitem>
          <para xml:lang="es">Pizza:</para>

          <programlisting>~.domain.Base roo-gvNIX&gt; <command>entity jpa --class ~.domain.Pizza --testAutomatically</command>
~.domain.Pizza roo-gvNIX&gt; <command>field string --fieldName name --notNull --sizeMin 2
		--comment "Nombre de la pizza" --column pizza_nombre --regexp [A-Za-z0-9].*</command>
~.domain.Pizza roo-gvNIX&gt; <command>field number --fieldName price --type java.lang.Float</command>
~.domain.Pizza roo-gvNIX&gt; <command>field set --fieldName toppings --type ~.domain.Topping</command>
~.domain.Pizza roo-gvNIX&gt; <command>field reference --fieldName base --type ~.domain.Base</command>
                </programlisting>

          <para xml:lang="es">Esta secuencia de comandos genera la siguiente
          clase Java:</para>

          <programlistingco>
            <areaspec>
              <area coords="10" xml:id="ex.regexp"/>

              <area coords="16" xml:id="ex.set"/>

              <area coords="21" xml:id="ex.entity"/>
            </areaspec>

            <programlisting>
@RooJavaBean
@RooToString
@RooJpaActiveRecord
public class Pizza {

    @NotNull
    @Column(name = "pizza_nombre")
    @Size(min = 2)
    @Pattern(regexp = "[A-Za-z0-9].*")
    private String name;

    private Float price;

    @ManyToMany(cascade = CascadeType.ALL)
    private Set&lt;Topping&gt; toppings =
      new HashSet&lt;Topping&gt;();

    @ManyToOne(targetEntity = Base.class)
    @JoinColumn
    private Base base;
}</programlisting>

            <calloutlist>
              <callout arearefs="ex.regexp">
                <para>Validación del texto</para>
              </callout>

              <callout arearefs="ex.set">
                <para xml:lang="es">Asociación con un conjunto de
                entidades</para>
              </callout>

              <callout arearefs="ex.entity">
                <para xml:lang="es">Asociación con otra entidad</para>
              </callout>
            </calloutlist>
          </programlistingco>
        </listitem>

        <listitem>
          <para xml:lang="es">PizzaOrder:</para>

          <programlisting>~.domain.Pizza roo-gvNIX&gt;<command>entity jpa --class ~.domain.PizzaOrder --testAutomatically</command>
~.domain.PizzaOrder roo-gvNIX&gt;<command>field string --fieldName name --notNull --sizeMin 2</command>
~.domain.PizzaOrder roo-gvNIX&gt;<command>field string --fieldName address --notNull --sizeMax 30</command>
~.domain.PizzaOrder roo-gvNIX&gt;<command>field number --fieldName total --type java.lang.Float</command>
~.domain.PizzaOrder roo-gvNIX&gt;<command>field date --fieldName deliveryDate --type java.util.Date</command>
~.domain.PizzaOrder roo-gvNIX&gt;<command>field set --fieldName pizzas --type ~.domain.Pizza</command>
                </programlisting>
        </listitem>
      </orderedlist>

      <para>En este punto, se ha completado la versión inicial del modelo del
      dominio</para>
    </section>
  </section>

  <section xml:id="guia-desarrollo_gestion-entidades_definicion_crear-a-mano">
    <title xml:lang="es">Crear una entidad con un IDE</title>

    <para xml:lang="es">Como se ha visto en el punto anterior, el código Java
    generado no tiene ningún elemento particular del framework, por lo que crear
    el modelo del dominio con cualquier IDE consiste en codificar las
    clases Java con las anotaciones que permiten a la consola monitorizar y generar
    el código.</para>

    <para>Es importante destacar que el objetivo de utilizar anotaciones
    es permitir que el proyecto se pueda gestionar codificando las clases
    con cualquier IDE. Entonces al arrancar la consola se generará toda la
    infraestructura necesaria para la persistencia, validación, etc</para>

    <para xml:lang="es">Entre las anotaciones que se pueden utilizar en la
    codificación del modelo de entidades, se pueden destacar:</para>

    <variablelist>
      <varlistentry>
        <term>@RooJavaBean</term>

        <listitem>
          <para xml:lang="es">Anotación que implica la generación de los
          getter/setter que falten para acceder/modificar los valores de
          las propiedades. Si alguno ya estuviese generado, no se
          volverá a generar.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>@RooToString</term>

        <listitem>
          <para xml:lang="es">Anotación que implica la generación del
          método <methodname>toString()</methodname> para esta
          clase. Este método se genera a partir de las propiedades de la
          clase.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>@RooJpaActiveRecord</term>

        <listitem>
          <para xml:lang="es">Anotación que identifica esta clase como
          persistente, es decir, la marca como una entidad. Esta anotación
          genera todos lo métodos de persistencia necesarios
          para crear, leer, actualizar y borrar (CRUD) la
          entidad siguiendo un patrón de registro activo.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <important>
      <para>Notar que para usar las anotaciones hay que importar sus
      clases:</para>

<programlisting>import org.springframework.roo.addon.javabean.RooJavaBean;
import org.springframework.roo.addon.jpa.activerecord.RooJpaActiveRecord;
import org.springframework.roo.addon.tostring.RooToString;</programlisting>
    </important>

    <para>Consultar la <link
    xlink:href="http://docs.spring.io/spring-roo/reference/html/">
    documentación oficial de Roo</link>
    para un detalle exhaustivo de las anotaciones.</para>
  </section>

  <section xml:id="guia-desarrollo_gestion-entidades_definicion_modificar-modelo">
    <title xml:lang="es">Modificar una entidad</title>

    <para xml:lang="es">Si se desea añadir un atributo a una entidad existente
    puede hacerse desde la consola. Cuando se crea o modifica una entidad,
    la consola se situa en el contexto de dicha entidad.
    Por eso en el ejemplo anterior, al añadir campos tras crear
    la entidad PizzaOrder, no es necesario especificar en
    cada comando la entidad sobre la que se están incluyendo.</para>

    <variablelist>
      <varlistentry>
        <term>Añadir un atributo</term>

        <listitem>
          <para xml:lang="es">Para añadir un nuevo campo deberemos usar el
          mismo comando <emphasis role="bold">field</emphasis> indicando sobre
          que entidad queremos trabajar mediante el parámetro
          <emphasis>--class.</emphasis><programlisting><command>field string --fieldName refCode --notNull --sizeMin 2 --class ~.domain.Pizza</command>
~.domain.Pizza roo-gvNIX&gt; </programlisting>Notar que tras ejecutar el
          comando <emphasis>field</emphasis> indicando el parámetro
          <emphasis>--class</emphasis> la consola cambia al contexto de la
          entidad Pizza y por tanto si se sigue ejecutando el comando field
          sin indicar <emphasis>--class</emphasis> los campos se añadirán a
          esta entidad.</para>

          <note>
            <para>Es posible situarse en el contexto de una entidad (o
            de cualquier clase del proyecto) mediante el comando <emphasis
            role="bold">focus</emphasis> indicando el parámetro
            <emphasis>--class</emphasis>.</para>

            <programlisting>roo-gvNIX&gt; <command>focus --class ~.domain.PizzaOrder</command>
~.domain.PizzaOrder roo-gvNIX&gt;</programlisting>
          </note>
        </listitem>
      </varlistentry>
    </variablelist>

    <para xml:lang="es">A diferencia de la creación de entidades, la
    modificación del modelo del dominio debe realizarse modificando
    la clase Java de la entidad, por ejemplo, mediante un IDE de
    desarrollo.</para>

    <variablelist>
      <varlistentry>
        <term>Eliminar una entidad</term>

        <listitem>
          <para xml:lang="es">Borrar el fichero <filename>.java</filename> de
          que define la entidad y automáticamente se detectará el cambio y se
          eliminarán todos los elementos relacionados: ficheros
          <filename>{entidad}_*.aj</filename>, controladores asociados,
          elementos de menú, etc.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Eliminar un atributo</term>

        <listitem>
          <para xml:lang="es">Borrar el atributo de la clase Java y todos los
          componentes relacionados <filename>{entidad}_*.aj</filename>
          serán actualizados automáticamente.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Modificar un atributo</term>

        <listitem>
          <para xml:lang="es">Modificar el atributo deseado en la clase Java y
          se actualizarán todos los ficheros <filename>{entidad}_*.aj</filename>
          relacionados para contemplar los cambios.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>

  <section xml:id="guia-desarrollo_gestion-entidades_definicion_identificadores-compuestos">
    <title xml:lang="es">Identificadores compuestos</title>

    <para>En el caso de necesitar que alguna de las entidades tenga
    definida una clave primaria compuesta de varios campos se debe hacer de
    la siguiente forma.</para>

    <programlisting><command>entity jpa --class ~.domain.Entity --identifierType ~.domain.EntityPK</command></programlisting>

    <para>De esta forma se genera una clase <emphasis>EntityPK</emphasis>
    sobre la que definir los campos que conformarán el identificador compuesto y
    que se corresponderán en el modelo relacional de base de datos con una clave primaria compuesta.
    La entidad usará la la clase que representa la clave compuesta, en el ejemplo:
    <emphasis>Entity</emphasis>.</para>

    <programlisting><command>field number --fieldName campo1 --type java.lang.Long</command>
...
<command>field string --fieldName campo2</command>
...</programlisting>

    <para>Se obtendrá una entidad en la que el tipo del campo identificador es
    un objeto con distintos campos. Este mecanismo es el mismo que se emplea
    al realizar la <link
    linkend="guia-desarrollo_entidades-dbre_clave_compuesta">ingeniería
    inversa</link> de una BBDD en el caso de que se encuentre una estructura
    de este tipo, es decir, una clave primaria compuesta.</para>

    <para>Otra forma de hacer lo mismo sería definir primero la clase que
    servirá de identificador (en el ejemplo <emphasis>EntityPK</emphasis>) y
    luego definir la entidad indicando que el identificador es del tipo de la
    clase que hemos creado previamente.</para>

    <programlisting><command>embeddable --class ~.domain.Entity2PK</command>
...
<command>field number --fieldName campo1 --type java.lang.Long</command>
...
<command>field string --fieldName campo2</command>
...
<command>entity jpa --class ~.domain.Entity2 --identifierType ~.domain.EntityPK2</command>
...
</programlisting>
  </section>

  <section xml:id="guia-desarrollo_gestion-entidades_enlazar-base-datos-existente">
    <title xml:lang="es">Definir características específicas para el modelo relacional</title>

    <para xml:lang="es">Una vez construido el modelo de entidades de la aplicación
    mediante ingeniería directa, tal y como se ha visto hasta ahora, al arrancar la aplicación
    se creará automáticamente el modelo relacional de base de datos a partir del modelo de entidades.
    Puede ocurrir que se desee que el modelo relacional de base de datos tenga
    algunas características específicas, en estos casos se pueden modificar las clases Java y
    plasmar las características específicas deseadas. Observar que todas las características
    específicas que se van a adaptar modificando la clase Java de las entidades pueden ser definidas
    en la definición inicial realizada con los comandos <emphasis>entity</emphasis> y
    <emphasis>field</emphasis>.</para>

    <section xml:id="guia-desarrollo_gestion-entidades_enlazar-base-datos-existente_tablas">
      <title>Definir un nombre de tabla</title>

      <para>Con la anotación de clase
      <classname>@RooJpaActiveRecord(..., table = "table_name")</classname>
      se puede definir el nombre de la tabla donde se guardará la información
      asociada con la entidad.</para>

      <example>
        <title>Uso de la anotación</title>

        <programlisting>
@RooJavaBean
@RooToString
@RooJpaActiveRecord(table = "entity_1")
public class Entity1 {

    private String field1;
}</programlisting>
      </example>
    </section>

    <section xml:id="guia-desarrollo_gestion-entidades_enlazar-base-datos-existente_columnas">
      <title>Definir un nombre de columna</title>

      <para>Existen varias anotaciones que permiten definir la correspondencia
      entre atributos de una entidad y las columnas de la tabla.</para>

      <para>Las más importantes son:</para>

      <variablelist>
        <varlistentry>
          <term><classname><link
          xlink:href="http://docs.oracle.com/javaee/6/docs/api/javax/persistence/Column.html">@Column</link></classname></term>

          <listitem>
            <para>Indica el nombre de la columna de la base de datos en donde se almacenará el
            valor del atributo. Si se omite esta anotación se aplicará una convención
            por la que el nombre de la columna será el mismo que el del atributo de la clase.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><classname><link
          xlink:href="http://docs.oracle.com/javaee/6/docs/api/javax/persistence/Transient.html">@Transient</link></classname></term>

          <listitem>
            <para>Indica que el atributo de la clase Java no tiene
            representación en la tabla (no será cargado ni almacenado).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><classname><link
          xlink:href="http://docs.oracle.com/javaee/6/docs/api/javax/persistence/JoinColumn.html">@JoinColumn</link></classname>,
          <classname><link
          xlink:href="http://docs.oracle.com/javaee/6/docs/api/javax/persistence/JoinColumns.html">@JoinColumns</link></classname>,
          <classname><link
          xlink:href="http://docs.oracle.com/javaee/6/docs/api/javax/persistence/OneToOne.html">@OneToOne</link></classname>,
          <classname><link
          xlink:href="http://docs.oracle.com/javaee/6/docs/api/javax/persistence/ManyToOne.html">@ManyToOne</link></classname></term>

          <listitem>
            <para>Define la correspondencia de una asociación
            <emphasis>N-1.</emphasis></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><classname><link
          xlink:href="http://docs.oracle.com/javaee/6/api/javax/persistence/JoinTable.html">@JoinTable</link></classname>,
          <classname><link
          xlink:href="http://docs.oracle.com/javaee/6/api/javax/persistence/OneToMany.html">@OneToMany</link></classname>,
          <classname><link
          xlink:href="http://docs.oracle.com/javaee/6/api/javax/persistence/ManyToMany.html">@ManyToMany</link></classname>,
          <classname><link
          xlink:href="http://docs.oracle.com/javaee/6/api/javax/persistence/OrderBy.html">@OrderBy</link></classname></term>

          <listitem>
            <para>Define la correspondencia de una asociación
            <emphasis>1-N</emphasis> o <emphasis>N-M.</emphasis></para>
          </listitem>
        </varlistentry>
      </variablelist>

      <example>
        <title>Uso de las anotaciones</title>

        <programlistingco>
          <areaspec>
            <area coords="8" xml:id="ex.annot.field"/>

            <area coords="11" xml:id="ex.annot.trans"/>

            <area coords="13" xml:id="ex.annot.preci"/>

            <area coords="16" xml:id="ex.annot.many"/>

            <area coords="17" xml:id="ex.annot.join"/>

            <area coords="20" xml:id="ex.annot.one"/>
          </areaspec>

          <programlisting>
@RooJavaBean
@RooToString
@RooJpaActiveRecord(name = "ENT1")
public class Entity1 {

    private String field1;

    @Transient
    private String tmpInfo;

    @Column(name="ORDER_COST", precision=12, scale=2)
    private BigDecimal cost;

    @ManyToOne(targetEntity = Customer.class)
    @JoinColumn(name = "CUSTOMER_ID")
    private Customer customer;

    @OneToMany(cascade = CascadeType.ALL, mappedBy = "entity1")
    private Set&lt;Price&gt; prices = new java.util.HashSet&lt;Price&gt;();
}</programlisting>

          <calloutlist>
            <callout arearefs="ex.annot.field">
              <para>Este campo se cargará y almacenará en la columna
              <literal>field1</literal> de la tabla
              <literal>ENT1</literal></para>
            </callout>

            <callout arearefs="ex.annot.trans">
              <para>Este campo no se tendrá en cuenta en la carga y guardado
              de la base de datos.</para>
            </callout>

            <callout arearefs="ex.annot.preci">
              <para>Este campo numérico se cargará y almacenará en la columna
              <literal>ORDER_COST</literal> de la tabla
              <literal>ENT1</literal>, usando los valores de
              <emphasis>precisión</emphasis> y <emphasis>escala</emphasis>
              especificados.</para>
            </callout>

            <callout arearefs="ex.annot.many">
              <para>Declara que la propiedad tiene origen en una relación
              <emphasis>n-1</emphasis>, con la entidad
              <classname>Customer</classname>. La tabla relacionada y sus
              columnas se obtendrán de las declaraciones que se hayan hecho en
              dicha entidad.</para>
            </callout>

            <callout arearefs="ex.annot.join">
              <para>Especifica que la columna de clave ajena en la tabla
              <literal>ENT1</literal> para esta relación (con
              <classname>Customer</classname>) es
              <literal>CUSTOMER_ID</literal></para>
            </callout>

            <callout arearefs="ex.annot.one">
              <para>Declara que el campo <literal>prices</literal> es una
              relación <emphasis>1-n</emphasis> con la entidad
              <literal>Price</literal>. También declara que los cambios
              (actualización, borrado, creación, ...) de
              <literal>Entity1</literal> se aplican en cascada sobre
              <literal>Price</literal>. El campo (propiedad en la clase java)
              que estable la clave ajena en <literal>Price</literal> se llama
              <literal>entity1</literal>.</para>
            </callout>
          </calloutlist>
        </programlistingco>
      </example>
    </section>

    <section>
      <title>Campos calculados</title>

      <para>Los campos <emphasis>@Transient</emphasis> son de utildad cuando
      necesitamos que en el Objeto de la entidad se almacene o se calcule
      algún dato y que este no se tenga en cuenta al guardar (sentencias
      insert o update) la instancia en la BBDD. Por ejemplo, una entidad
      Persona puede tener la siguiente declaración de campos:</para>

      <programlisting>public class Persona {

    private String name;
    private String lastName;

    <emphasis role="bold">@Transient</emphasis>
    private String fullName;
}</programlisting>

      <para>Con esta declaración existe la posibildad de guardar
      temporalemente en el campo <emphasis>fullName</emphasis> la
      concatenación de <emphasis>name</emphasis> y
      <emphasis>lastName</emphasis>, por motivos de simplicidad, y sin tener
      que modificar la estructura de la tabla de la BBDD para ello.</para>

      <para>Usando Hibernate como proveedor de persistencia, existe
      una anotación que puede ser útil para que un registro dado se calcule de manera automática
      haciendo una cosulta sobre la BBDD. Se trata de la anotación
      <emphasis>org.hibernate.annotations.Formula</emphasis>.</para>

      <para><emphasis>@Formula</emphasis> tiene como atributo una cadena que
      se usa como sentencia HQL. Esta se ejecuta cada vez que se carga el
      registro de la BBDD y el resultado se almacena en el campo con esta
      anotación. Siguiendo con el ejemplo anterior, se podría tener lo siguiente:</para>

      <programlisting>public class Persona {

    private String name;
    private String lastName;

    <emphasis role="bold">@Formula("(SELECT name || ' ' || lastName from persona)")</emphasis>
    private String fullName;
}</programlisting>

      <para>En el ejemplo cuando se carga una instancia de la entidad persona
      se ejecutará la consulta definida y en el campo fullName estará
      disponible el resultado de la consulta. La cosulta puede ser tan
      compleja como sea necesario, incluso incluir subconsultas. El campo
      anotado con <emphasis>@Formula</emphasis> es tratado como solo
      lectura y, por tanto, no se tendrá en cuenta en las operaciones de
      escritura de la BBDD.</para>

      <para>Otra forma de calcular valores, sin el uso de campos de la BBDD,
      consiste en declarar un método en la entidad que realice las operaciones
      necesarias para devolver el valor calculado. De esta forma, se podrá
      acceder al cálculo sin tener que declarar un campo (con sus respectivos
      get/set).</para>
    </section>

    <section xml:id="guia-desarrollo_gestion-entidades_enlazar-base-datos-existente_clave-primaria">
      <title>Clave primaria</title>

      <para>Por defecto, una clave primaria se representa en la clase java
      como una propiedad con nombre <emphasis>id</emphasis>
      y tipo <classname>java.lang.Long</classname>.
      A continuación se muestra un ejemplo de cómo se pueden cambiar distintas
      características.</para>

      <para>Modificar la anotación @RooJpaActiveRecord
      para ajustar el nombre y el tipo de la columna que hace
      de clave primaria en la tabla o el nombre de la propiedad
      identificadora en la clase.</para>

      <example>
        <title>Uso de las anotaciones</title>

        <programlisting>
@RooJavaBean
@RooToString
@RooJpaActiveRecord(identifierField="ent1Id",
        identifierType=Long.class, identifierColumn="ENT_ID")
public class Entity1 {

    private String field1;

}</programlisting>
      </example>

       <para>Observar que todas estas características se pueden
       especificar en el momento de la creación de la entidad
       mediante el comando <emphasis>entity</emphasis>.</para>

       <para>Si se utiliza Hibernate como proveedor ORM, usará la
       secuencia <emphasis>hibernate_sequence</emphasis> para obtener
       de forma incremental el identificador al crear un nuevo registro en la entidad.
       Por tanto, esta secuencia debe existir en la BBDD sobre la que
       se ejecuta la aplicación, de lo contrario se producirá un error al
       no poder obtener el siguiente valor de la sequencia antes de crear
       un nuevo registro. Por defecto, todas las entidades utilizarán la misma secuencia para
       obtener los identificadores de los registros que se vayan creando.</para>

       <para>Si se necesita especificar una sequencia distinta para generar
       los identificador para cada Entidad se puede utilizar el atributo
       <emphasis>--sequenceName</emphasis> del comando <emphasis>entity</emphasis>.
       Si la entidad ya fue creada con anterioridad y no se desea volver a crearla
       mediante el comando con la nueva característica,
       modificar la anotación @RooJpaActiveRecord de la siguiente forma:</para>

          <programlisting>
@RooJavaBean
@RooToString
@RooJpaActiveRecord(sequenceName="ent1_seq_generator")
public class Entity1 {

    private String field1;

}</programlisting>

       <para>Como se ha comentado, las secuencias que se usan
       en las Entidades han de existir en la BBDD. Se deberán crear
       mediante la sintaxis propia de la BBDD o bien delegarlo
       en Hibernate modificando la propiedad del archivo
       <emphasis>persistence.xml</emphasis>,
       <emphasis>hibernate.hbm2ddl.auto</emphasis> con valor
       <emphasis>update</emphasis> de forma que, al arrancar la aplicación,
       creará las secuencias necesarias. <emphasis role="bold">Consultar
       con el administrador de BBDD si se permite la creación de nuevas
       estructuras.</emphasis>.</para>

       <para>Cuando se usa una secuencia como identificador, antes de
       insertar un nuevo registro, el ORM consulta el valor de
       la secuencia que debe asiganarle. Esto implica una cosulta por cada
       inserción, con el consecuente sobrecoste. Hibernate, por defecto,
       intenta evitar este sobrecoste reservando un conjunto de valores de la
       secuencia la primera vez que se usa tras arrancar la aplicación (por
       defecto reserva los siguientes 50). Mientras no consuma estos
       valores, no volverá a solicitar el siguiente valor de la secuencia.
       Para más información sobre la optimización de generadores de
       secuencia consultar la <link
       xlink:href="http://docs.jboss.org/hibernate/core/3.3/reference/en/html/mapping.html#mapping-declaration-id-enhanced-optimizers">documentación
       de Hibernate</link>. Es posible modificar este comportamiento
       haciendo push-in de la propiedad id y añadiendo
       a la anotación <emphasis>@SequenceGenerator</emphasis> el atributo
       <emphasis>allocationSize = 1.</emphasis></para>

    </section>

    <section xml:id="guia-desarrollo_gestion-entidades_enlazar-base-datos-existente_campo-control-optimista">
      <title>Campo para el control de concurrencia optimista.</title>

      <para>En la ingeniería directa, por defecto, para cada entidad
      se genera un campo de control de concurrencia
      optimista con nombre <literal>version</literal> y de tipo
      <classname>java.lang.Integer</classname></para>

	<para>El control por versión utiliza números de versión, o sellos de fecha
	(timestamps), para detectar actualizaciones en conflicto y prevenir la
	pérdida de actualizaciones. Cuando 2 usuarios actualizan el mismo registro de
	forma simultánea, sin control de concurrencia, los cambios del segundo usuario
	en actualizar sobreescriben los datos actualizados por el primer, dando la
	sensación al primer usuario que sus datos se perdieron o nunca existieron.</para>

	<para>En el control de concurrencia por versión hay una columna <emphasis>Version</emphasis> en la
	tabla de base de datos que se mapea a un atributo de la entidad anotado con
	<emphasis>@Version</emphasis>. Al hacer update o delete se añade al WHERE la clave primaria
	y la comparación de versión, <emphasis>si version != VERSION_DB</emphasis> no se actualiza nada.
	</para>

	<para>Observar que todas estas características se pueden especificar en el
	momento de la creación de la entidad mediante el comando entity.
	Para ajustarlo posteriormente existen otras opciones:</para>

      <orderedlist>
        <listitem>
          <para>Configurar la anotación @RooJpaActiveRecord para ajustar el nombre del
          campo, el nombre de la columna y el tipo de datos.</para>

          <programlisting>
@RooJavaBean
@RooToString
@RooJpaActiveRecord(versionField="version",
        versionType=Long.class, versionColumn="ENT_ID")
public class Entity1 {

    private String field1;

}</programlisting>
        </listitem>

        <listitem>
          <para>Otro ejemplo desactivando el control de concurrencia
          optimista:</para>

          <programlisting>
@RooJavaBean
@RooToString
@RooJpaActiveRecord(versionField="")
public class Entity1 {

    private String field1;

}</programlisting>
        </listitem>

      </orderedlist>

      <para>Mas adelante se verán otros mecanismos para realizar un
      control de concurrencia optimista. Para más información
      consultar el comando <command><link
      linkend="apendice-comandos_addon-persistence_occchecksum_occ-checksum-set">
      occ checksum set</link></command>.</para>

    </section>

    <section xml:id="guia-desarrollo_gestion-entidades_enlazar-base-datos-existente_regeneracion-bbdd">
      <title xml:lang="es">Regeneración de la Base de datos en cada
      arranque.</title>

      <para xml:lang="es">Recordar que por defecto, en la ingeniería directa,
      la configuración que se genera
      <emphasis role="bold">reconstruye la base de datos en cada ejecución de
      la aplicación</emphasis>. Si se desea modificar este comportamiento
      consultar la sección
      <link linkend="guia-desarrollo_acceso-datos_actualizacion-esquema">
      Actualización automática del esquema</link>
      .</para>
    </section>

    <section>
      <title>Creación de una nueva entidad sin comandos</title>

      <para>En el ejemplo que se está siguiendo a lo largo de la documentación,
      se puede definir una nueva entidad <emphasis>Repartidor</emphasis>
      creando la siguiente clase Java. También se puede realizar
      su creación mediante los comandos <emphasis>entity</emphasis> y
      <emphasis>field</emphasis>.</para>

      <programlisting>package com.springsource.roo.pizzashop.domain;

import org.springframework.roo.addon.javabean.RooJavaBean;
import org.springframework.roo.addon.jpa.activerecord.RooJpaActiveRecord;
import org.springframework.roo.addon.tostring.RooToString;

@RooJavaBean
@RooToString
@RooJpaActiveRecord
public class Repartidor {

        private String name;
}</programlisting>

      <para>Observar que al salvar la clase Java con las anotaciones correspondientes,
      en la consola aparecen mensajes informando de la creación de distintos ficheros
      de aspectos java (*.aj). A continuación, se puede generar los test de integración
      para la nueva entidad y definir una relación entre PizzaOrder y el Repartidor del pedido.</para>

      <programlisting><command>test integration --entity ~.domain.Repartidor</command>
...
<command>field reference --class ~.domain.PizzaOrder --fieldName repartidor
		--type ~.domain.Repartidor</command>
...</programlisting>

      <para>Finalmente, lanzar los test de integración para confirmar que
      todo se ha generado y funciona correctamente.</para>

      <programlisting>roo-gvNIX&gt; <command>perform tests
</command>...
[INFO] BUILD SUCCESSFUL</programlisting>
    </section>
  </section>

  <section xml:id="guia-desarrollo_gestion-entidades_ingenieria-inversa">
    <title xml:lang="es">Ingeniería inversa de entidades</title>

    <para xml:lang="es">El framework permite realizar una ingeniería inversa
    multiesquema e incremental de un modelo relacional de base de datos existente,
    de forma que basándose en la metainformación recopilada de la BBDD se generarán todas
    las entidades con sus respectivos campos de manera automática.
    El encargado de esta funcionalidad es el
    Add-on <emphasis>Database Reverse Engineering</emphasis> disponible
    en el framework de forma automática.</para>

    <section xml:id="guia-desarrollo_ingenieria-inversa_instalacion">
      <title>Instalación del driver JDBC</title>

      <para>El Add-on DBRE soporta las principales bases de datos
      relacionales del mercado (MySQL, MS SQL, PostgreSQL, Oracle, ...).
      El driver necesario será detectado y se ofrecerá
      su descarga e instalación automática la primera vez que lo requiera
      alguno de los comandos <emphasis>database introspect</emphasis> o
      <emphasis>database reverse engineer.</emphasis></para>

      <para><warning>
          <para>Si se está trabajando en el entorno de la CITMA, antes de seguir
          adelante es recomendable añadir el repositorio Maven de la CITMA
          al pom.xml del proyecto. En la <link
          linkend="recetas-repositorio_maven">sección de recetas</link> existe un
          ejemplo de como hacerlo.</para>
        </warning><warning>
          <para>Si se lanza este comando con la configuración actual del
          proyecto que usa HYPERSONIC_PERSISTENT como BBDD indicará que no
          hay driver disponible para HSQLDB.</para>
        </warning>Por ejemplo, si se ejecuta la ingeniería inversa en un proyecto con
        PostgreSQL configurado como sistema de base de datos:

        <programlisting>roo-gvNIX&gt; <emphasis role="bold">database introspect --schema unable-to-obtain-connection</emphasis>
Located add-on that may offer this JDBC driver
1 found, sorted by rank; T = trusted developer; R = Roo 1.2 compatible
ID T R DESCRIPTION -------------------------------------------------------------
01 Y Y 9.1.0.901_0001 Postgres #jdbcdriver...
--------------------------------------------------------------------------------
[HINT] use 'addon info id --searchResultId ..' to see details about a search result
[HINT] use 'addon install id --searchResultId ..' to install a specific search result, or
[HINT] use 'addon install bundle --bundleSymbolicName TAB' to install a specific
		add-on version
JDBC driver not available for 'org.postgresql.Driver'</programlisting>Esta
      salida del comando <emphasis>database
      introspect</emphasis> informa que hay disponible un driver para el
      soporte de DBRE y sugiere qué hacer a continuación (lineas que
      empiezan con [HINT]).</para>

      <para>Se puede obtener más información sobre el driver mediante:</para>

      <programlisting>roo-gvNIX&gt; <command>addon info id --searchResultId 01</command>
Name.........: Spring Roo - Wrapping - postgresql-jdbc4
BSN..........: org.springframework.roo.wrapping.postgresql-jdbc4
Version......: 9.1.0.901_0001 [available versions: 9.0.801.0001,
               9.1.0.901_0001]
Roo Version..: 1.2
Ranking......: 0.0
JAR Size.....: 513073 bytes
PGP Signature: 0xEC67B395 signed by Alan Stewart (stewarta@vmware.com)
OBR URL......: http://spring-roo-repository.springsource.org/repository.xml</programlisting>

      <para>Donde se está pidiendo más información
      (--searchResultId) del Add-on 01 que ha devuelto el comando
      anterior.</para>

      <para>Para instalarlo usar el id del Add-on o bien su
      nombre simbólico.<programlisting><command>addon install id --searchResultId 01</command></programlisting></para>

      <para>o</para>

      <programlisting><command>addon install bundle
      		--bundleSymbolicName org.springframework.roo.wrapping.postgresql-jdbc4</command></programlisting>

      <para>Al instante estará disponible el driver JDBC y se podrá empezar
      a usar los comandos <emphasis>database introspect</emphasis> y
      <emphasis>database reverse.</emphasis></para>

    </section>

    <section>
      <title>Comandos de la ingeniería inversa</title>

      <para>DBRE ofrece dos comandos: <emphasis>database introspect</emphasis>
      y <emphasis>database reverse engineer.</emphasis></para>

      <programlisting><command>database introspect --schema</command> &lt;nombre del esquema&gt;
      		--file &lt;nombre del fichero&gt; --enableViews</programlisting>

      <para>El comando mostrará la estructura de la BBDD en formato XML.
      Es obligatorio indicar el esquema, para ello
      presionado la tecla TAB se mostrará la lista de esquemas de la
      BBDD. Algunas BBDD no usan el concepto de esquema, MySQL entre ellas,
      aun así la opción --schema es necesaria y por ello el asistente
      mostrará como esquema "no-schema-required". La opción --file indica que
      guarde la información también en un fichero determinado y --enableViews
      especifica que también debe obtener información sobre las vistas.</para>

      <programlisting><command>database reverse engineer --schema</command>
      		--package --testAutomatically --enableViews --includeTables
      		--excludeTables --includeNonPortableAttributes</programlisting>

      <para>Este comando crea las entidades JPA del proyecto
      representando las tablas y columnas de la BBDD. Al igual que antes
      --schema es obligatorio. Se debe usar --package para indicar el nombre
      del paquete del proyecto donde crear las clases Java, como convención
      se recomienda utilizar el subpaquete domain dentro del paquete base,
      ese decir, <emphasis>~.domain</emphasis>.</para>

      <para>Podemos indicar también que se generen automáticamente los test de
      integración para cada una de las nuevas entidades creadas con
      --testAutomatically.</para>

      <para>Si se especifica la opción --enableViews en este comando, se crearan
      entidades JPA que representen las vistas que se encuentren en la
      inspección de la BBDD.</para>

      <para>Se pueden filtrar las tablas que se van a considerar en la
      operación. --includeTables indicará cuales son las tablas que deben
      ser tenidas en cuenta. Se pueden indicar uno o varios nombres de
      tabla, si se indican más de uno, se deberán especificar separadas por
      espacios y todas ellas entre comillas dobles.
      Se permite el uso de * para hacer matching de uno o varios
      caracteres en la búsqueda o el uso de ? para indicar un único caracter.
      De manera opuesta --excludeTables indica qué tablas no han de ser
      tenidas en cuenta durante la ingeniería inversa y admite el mismo uso de
      * y ?. Las exclusiones de tablas son requeridas especialmente en aquellas
      ocasiones en las que tablas incluidas en la ingeniería inversa tienen
      relaciones con otras tablas no incluidas, por lo que estas segundas deberán
      excluirse. Un ejemplo:</para>

      <programlisting>database reverse engineer --schema no-schema-required
      		--package ~.domain --includeTables "foo* bar?"</programlisting>

      <para>Con este comando se generarían las entidades de aquellas tablas de
      la BBDD que tengan como nombre foo&lt;cualquier cosa&gt; y bar&lt;otro
      caracter más&gt;, por ejemplo 'foo_tabla_cool' y 'bars'.</para>

      <warning>
        <para>Al excluir tablas, además de evitar que se creen las entidades
        de estas tablas se evita también que se creen las asociaciones y
        relaciones en otras entidades. Esto se hace para evitar problemas de
        compilación en el código del proyecto.</para>
      </warning>

      <para>Como DBRE ofrece ingeniería inversa incremental, se puede ejecutar
      este comando tantas veces como sea necesario y de esta forma se
      mantendrán todas las entidades JPA de manera automática.</para>

      <para>El parámetro <emphasis
      role="bold">--includeNonPortableAttributes</emphasis> puede ser de
      utilidad. En versiones anteriores de la funcionalidad de ingeniería
      inversa de BBDD este parámetro no existía y, por defecto, cuando se
      generaban las entidades se incluía en las anotaciones JPA un atributo
      que rompía la portabilidad del código Java para trabajar con BBDD
      distintas a la de origen. El atributo en cuestión es
      <emphasis>columnDefinition</emphasis> en la anotación <emphasis>@Column</emphasis>,
      que sirve para indicar el tipo de
      dato usado para crear la columna en la BBDD. Este atributo se utiliza en
      dos fases: cuando se delega en JPA la creación de las tablas de la BBDD
      (propiedad <emphasis>hibernate.hbm2ddl.auto</emphasis> con valor
      <emphasis>create</emphasis> de Hibernate), de esta forma se indica el
      tipo de dato físico utilizado en la BBDD y también se utiliza en la fase
      de validación del esquema de BBDD en el arranque de la aplicación
      (propiedad <emphasis>hibernate.hbm2ddl.auto</emphasis> con valor
      <emphasis>validate</emphasis>), que comprueba que las entidades del
      proyecto cumplen con el esquema de BBDD y por tanto son
      compatibles.</para>

      <para>Por lo tanto, hay que tener en cuenta este detalle al hacer la
      ingeniería inversa de la BBDD. Si se va a seguir trabajando con la misma
      BBDD, se puede optar por requerir que se incluyan los atributos
      "no portables" en la generación de las entidades. Por contra, si la
      aplicación se va a ejecutar en distintas bases de datos, es mejor no incluir
      estos atributos y no usar este parámetro del comando <emphasis>database
      reverse engineer</emphasis>.</para>

      <important>
        <para>Cuando se utiliza el Add-on de ingeniería inversa se
        modifica el fichero META-INF/persistence.xml cambiando el valor de la
        propiedad <emphasis>hibernate.hbm2ddl.auto</emphasis> por el de
        <emphasis>none</emphasis> para evitar poner en peligro la
        integridad de la BBDD a la que se está conectando desde el proyecto.
        Si se ha utilizado la opción --includeNonPortableAttributes
        el valor de esta propiedad será
        <emphasis>validate</emphasis> de modo que en el arranque de la aplicación
        se realizará la fase de validación del esquema.</para>
      </important>

      <important>
	      <para>Si se realiza la ingeniería inversa de alguna vista,
	      es recomendable leer la sección <link
	      linkend="guia-desarrollo_gestion-entidades_ingenieria_inversa-vistas">
	      Ingeniería inversa de vistas</link> ya que puede ser necario
	      realizar alguna personalización.</para>
      </important>
    </section>

    <section>
      <title>Anotación @RooDbManaged</title>

      <para>Tal y como se ha comentado en la sección <link
      linkend="guia-desarrollo_gestion-entidades_definicion_crear-a-mano">Crear
      una entidad con un IDE</link> se hace uso de una serie de anotaciones
      Java para que el framework gestione el código del proyecto. A las anotaciones
      descritas anteriormente se suma ahora la anotación @RooDbManaged que se
      añade a todas las entidades creadas durante el proceso de ingeniería
      inversa.</para>

      <programlisting>@RooJavaBean
@RooToString
<command>@RooDbManaged</command>(automaticallyDelete = true)
@RooJpaActiveRecord
public class Pizza {
}</programlisting>

      <para>El atributo <emphasis>automaticallyDelete</emphasis> que acompaña
      a la anotación y que toma el valor <emphasis>true</emphasis> indica
      que se debe eliminar la entidad en el caso de que la tabla de la
      BBDD a la cual hace referencia sea eliminada. Si el atributo toma el
      valor <emphasis>false</emphasis> la entidad no se eliminará en caso de que la tabla
      desaparezca de la BBDD.</para>
    </section>

    <section>
      <title>Soporte de funcionalidades JPA 2.0</title>

      <para>El Add-on DBRE crea y mantiene claves primarias simples,
      claves primarias compuestas, relaciones entre entidades,
      restricciones tamaño, gestión de valores nulos, etc. A continuación,
      se verá como realiza la gestión de algunos de estos elementos.</para>

      <section>
        <title>Claves primarias simples</title>

        <para>Para el caso de claves primarias simples DBRE genera un campo
        identificador en el aspecto java de la entidad marcado con la anotación @Id
        de forma similar a como se hace al ejecutar el comando
        <emphasis>entity</emphasis>.</para>
      </section>

      <section xml:id="guia-desarrollo_entidades-dbre_clave_compuesta">
        <title>Claves primarias compuestas</title>

        <para>En este caso DBRE utiliza una solución más elaborada. Crea una
        clase Java que representa la clave primaria anotándola con
        @RooIdentifier(dbManaged = true) y añade el atributo "identifierType"
        con el nombre de la clase del identificador a la anotación @RooJpaActiveRecord
        en la clase de la entidad. Por ejemplo:</para>

        <programlisting>@RooJavaBean
@RooToString
@RooDbManaged(automaticallyDelete = true)
@RooJpaActiveRecord(identifierType = LineItemPK.class, table = "line_item",
		schema = "order")
public class LineItem {
}</programlisting>

        <programlisting>@RooIdentifier(dbManaged = true)
public class LineItemPK {
}</programlisting>

        <para>En el aspecto java de la entidad LineItem existirá un campo anotado con
        @EmbeddedId del tipo LineItemPK:</para>

        <programlisting>privileged aspect LineItem_Roo_Jpa_Entity {

    declare @type: LineItem: @Entity;

    declare @type: LineItem: @Table(name = "line_item", schema = "order");

    @EmbeddedId
    private LineItemPK LineItem.id;

    public LineItemPK LineItem.getId() {
        return this.id;
    }

    public void LineItem.setId(LineItemPK id) {
        this.id = id;
    }

    ...
}</programlisting>

        <para>Y en el aspecto java de la clase que representa la clave compuesta
        estarán los campos de la clave primaria con la anotación
        @Embeddable:</para>

        <programlisting>privileged aspect LineItemPK_Roo_Identifier {

    declare @type: LineItemPK: @Embeddable;

    @Column(name = "line_item_id", nullable = false)
    private BigDecimal LineItemPK.lineItemId;

    @Column(name = "order_id", nullable = false)
    private BigDecimal LineItemPK.orderId;

    public LineItemPK.new(BigDecimal lineItemId, BigDecimal orderId) {
        super();
        this.lineItemId = lineItemId;
        this.orderId = orderId;
    }

    private LineItemPK.new() {
        super();
    }

    ...
}</programlisting>
      </section>
    </section>

    <section>
      <title>Ingeniería inversa multi esquema</title>

      <para>La ingeniería inversa proporcionada por el framework
      ofrece soporte para la conexión con múltiples esquemas de la
      misma base de datos de forma automática.</para>

      <para>El opción <emphasis>--schema</emphasis> de los comandos
      de la ingeniería inversa permiten especificar una lista de esquemas
      separados por espacios y englobados todos ellos por dobles comillas.</para>

      <para>La ingeniería inversa también se puede hacer de
      distintas fuentes de datos utilizando para ello la documentación
      de la sección <link
      linkend="guia-desarrollo_gestion-acceso-datos_multiples-fuentes-datos">
      Múltiples fuentes de datos</link>.</para>

      <para/>
    </section>

    <section>
      <title>Ingeniería inversa incremental</title>

      <para>La ingeniería inversa proporcionada por el framework
      permite ejecutarse todas las veces que sea necesario de forma
      que se pueden modificar las características y elementos
      incluidos en ingenierías inversas anteriores.</para>

      <para>Si al hacer una ingeniería inversa no se incluyó
      alguna tabla que posteriormente se ha visto necesario,
      basta con volver a ejecutar el comando de ingeniería
      inversa incluyendo la nueva tabla. Todas las modificaciones
      realizadas sobre las entidades que ya existían no se perderán.</para>

      <para/>
    </section>

    <section>
      <title xml:lang="es" xml:id="guia-desarrollo_gestion-entidades_ingenieria_inversa-vistas">Ingeniería inversa de vistas</title>

      <para xml:lang="es">Tras realizar la ingeniería inversa de una
      vista de la base de datos es muy probable que se tengan que
      realizar algunas modificaciones manuales para que funcione
      correctamente y que no son posibles realizar de manera automática
      ya que se requiere tomar ciertas decisiones de diseño.</para>

      <para xml:lang="es">En una vista, por definición, no existe definida
      ninguna clave primaria. Sin embargo, al convertir esta estructura
      relacional al modelo orientado a objetos es necesario definir uno
      o varios campos que identifiquen de forma unívoca cada resultado
      que se vaya a obtener de la vista.</para>

      <para xml:lang="es">La ingeniería inversa de vistas, por defecto,
      configura todas las columnas de la vista como clave primaria compuesta.
      Es por ello que todas las propiedades serán creadas en la clase con sufijo
      PK, por ejemplo EntidadPK, y no se creará ninguna propiedad en la clase
      base, por ejemplo Entidad.</para>

      <para xml:lang="es">Habitualmente algunas columnas de la vista serán
      opcionales. Sin embargo, en el modelo orientado a objetos es incorrecto que
      alguna de las propiedades que representan a la clave primaria compuesta
      tenga valores nulos.</para>

      <para xml:lang="es">Es por ello que deberemos analizar el modo en el que está
      construida la vista en la base de datos para así identificar uno o varios
      campos que representen de forma unívoca cada resultado de la vista. En algunos
      casos en los que la vista de alimenta de otra tabla, la clave primaria de la
      vista suele ser la misma que la de la tabla.</para>

      <para xml:lang="es">Una vez detectadas las propiedades que conforman la clave
      primaria de la vista deberán realizarse las siguientes modificaciones:

      <para xml:lang="es">
	      <variablelist>
	        <varlistentry>
		        <term>Copiar propiedades en la entidad.</term>
		        <listitem>
		        <para xml:lang="es">
		        Copiar las propiedades de la clase EntidadPK que no representan a la clave primaria
		        en la clase Entidad. Las propiedades de la clase EntidadPK se encuentran en el
		        fichero EntidadPK_Roo_Identifier.aj. Al copiar las propiedades, recordar eliminar
		        el prefijo "EntidadPK." que tiene cada una de las propiedades.
		        </para>
		        </listitem>
	        </varlistentry>
	        <varlistentry>
		        <term>Modificar propiedades en la clave primaria.</term>
		        <listitem>
		        <para xml:lang="es">
				Hacer push-in de las propiedades de la clase EntidadPK que no representan a la clave primaria
		        compuesta, añadirles la anotación @Transient y eliminar cualquier otra anotación que tengan.
		        Las propiedades de la clase EntidadPK se encuentran en el fichero EntidadPK_Roo_Identifier.aj
		        y al hacer push-in pasarán a estar en el fichero EntidadPK.java.
		        </para>
		        </listitem>
	        </varlistentry>
	        <varlistentry>
		        <term>Desactivar operaciones en la capa de entidades.</term>
		        <listitem>
		        <para xml:lang="es">
				Añadir a la anotación @RooJpaActiveRecord de la clase Entidad los siguientes atributos
				que desactivarán el borrado, creación y actualización en la capa de entidades:
				removeMethod = "", persistMethod = "", mergeMethod = "".
				</para>
				</listitem>
	        </varlistentry>
	        <varlistentry>
		        <term>Desactivar operaciones en la capa web.</term>
		        <listitem>
		        <para xml:lang="es">
				Si se ha generado la capa web asociada a la entidad que representa a la vista,
				añadir a la anotación @RooWebScaffold de la clase EntidadController los siguientes atributos
				que desactivarán el borrado, creación y actualización en la capa web:
				removeMethod = "", persistMethod = "", mergeMethod = "".
				</para>
				</listitem>
	        </varlistentry>
	      </variablelist>
      </para>

      </para>

	    <section>
	      <title xml:lang="es" xml:id="guia-desarrollo_gestion-entidades_ingenieria_inversa-vistas-tests">
	      Tests de la ingeniería inversa de vistas</title>

	      <para xml:lang="es">En las vistas que no realizamos push-in e identificamos un
	      elemento como clave primaria hay que realizar los siguientes cambios si deseamos
	      mantenerlos ejecutándose con éxito.
	      Como ejemplo pondremos VaumAplusuPerfiles.</para>

	      <para xml:lang="es">
		      <variablelist>
		        <varlistentry>
			        <term>Realizar push-in</term>
			        <listitem>
			        <para xml:lang="es">
			        Realizar push-in de todos los métodos: persist, remove, los finder y count.
			        </para>
			        </listitem>
		        </varlistentry>
		        <varlistentry>
			        <term>Modificar count y persist</term>
			        <listitem>
			        <para xml:lang="es">
			        Al count y persist le eliminaremos la siguiente línea, que es la primera que tiene en código:
			        Assert.assertNotNull("Data on demand for 'VaumAplusuPerfiles' failed to initialize correctly", dod.getRandomVaumAplusuPerfiles());
			        Esto no afecta a la comprobación de si el count funciona correctamente.
			        </para>
			        </listitem>
		        </varlistentry>
		        <varlistentry>
			        <term>Modificar finder un resultado</term>
			        <listitem>
			        <para xml:lang="es">
			        Al finder de un objeto de la entidad en concreto (testFindVaumAplusuPerfiles) lo que haremos será insertar un objeto que sabemos que todos los valores no son null utilizando dod.getNewTransientVaumAplusuPerfiles(Integer.MAX_VALUE); y posteriormente buscaremos dicho elemento:
			        Sustituimos VaumAplusuPerfiles obj = dod.getRandomVaumAplusuPerfiles();
			        por VaumAplusuPerfiles obj = dod.getNewTransientVaumAplusuPerfiles(Integer.MAX_VALUE); obj.persist();
			        </para>
			        </listitem>
		        </varlistentry>
		        <varlistentry>
			        <term>Modificar finder de múltiples resultados</term>
			        <listitem>
			        <para xml:lang="es">
			        Al finder All y ...Entries tendremos que eliminar las líneas assertNotNull situadas al principio del método y justo debajo de obtener el listado.
			        Assert.assertNotNull("Data on demand for 'VaumAplusuPerfiles' failed to initialize correctly", dod.getRandomVaumAplusuPerfiles());
			        Assert.assertNotNull("Find all method for 'VaumAplusuPerfiles' illegally returned null", result);
			        </para>
			        </listitem>
		        </varlistentry>
		        <varlistentry>
			        <term></term>
			        <listitem>
			        <para xml:lang="es">
			        Al remove le sustetuiremos VaumAplusuPerfiles obj = dod.getRandomVaumAplusuPerfiles();
			        por VaumAplusuPerfiles obj = dod.getNewTransientVaumAplusuPerfiles(Integer.MAX_VALUE);
			        obj.persist();
			        </para>
			        </listitem>
		        </varlistentry>
		      </variablelist>
	      </para>

	    </section>
    </section>

  </section>

</chapter>

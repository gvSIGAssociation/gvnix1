<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="recetas" xml:lang="es"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:ns5="http://www.w3.org/1998/Math/MathML"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title xml:lang="es">Recetas</title>

  <para>TBC (de roo-addon-desarrollo.rst) [Las recetas que todavía sean
  válidas en M1. Ver si extraer alguna de los add-ons implementados]</para>

  <para>En este capitulo se incluyen una serie de recetas que pueden ser
  útiles en el desarrollo de framework para realizar algunas funciones
  comunes.</para>

  <section xml:id="recetas_clases-utilidad">
    <title>Clases de utilidad</title>

    <para>El framework provee de una serie de clases para la ayuda al add-on.
    Estas clases son abstractas con sus métodos declarados como estáticos.
    Entre ellas encontramos:</para>

    <variablelist>
      <varlistentry>
        <term>org.springframework.roo.support.util.FileCopyUtils</term>

        <listitem>
          <para>Utilidades de copia de ficheros.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>org.springframework.roo.support.util.FileUtils</term>

        <listitem>
          <para>Utilidades para manejo de ficheros.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>org.springframework.roo.support.util.DomUtils</term>

        <listitem>
          <para>Utilidades para el manejo del API Dom (búsquedas de elementos,
          etc...).</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>org.springframework.roo.support.util.Assert</term>

        <listitem>
          <para>Utilidades para hacer comprobaciones de parámetros y
          variables.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>org.springframework.roo.support.util.XmlUtils</term>

        <listitem>
          <para>Utilidases para editar o crear ficheros xml.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>org.springframework.roo.support.util.WebXmlUtils</term>

        <listitem>
          <para>Utilidades para actualizar el fichero web.xml en proyectos
          web.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>

  <section xml:id="recetas_servicios-framework">
    <title>Servicios del framework</title>

    <para>El framework provee de una serie de servicios (<link
    linkend="creacion-addon_osgi">componentes-servicios OSGi</link>) que
    podemos necesitar para desarrollar nuestros add-ons. Para usarlos debemos
    revisar que nuestro add-on tiene registradas la dependencias de los
    proyecto de cada bundle.</para>

    <variablelist>
      <varlistentry>
        <term>org.springframework.roo.process.manager.FileManager</term>

        <listitem>
          <para>Servicios para modificación de ficheros. Es necesario su uso
          para habilitar el soporte de <emphasis>deshacer cambios ante un
          fallo</emphasis>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>org.springframework.roo.project.PathResolver</term>

        <listitem>
          <para>Ayudas para el manejo de rutas de fichero dentro de proyecto
          (obtener rutas absolutas a partir de relativas al proyecto).</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>org.springframework.roo.metadata.MetadataService</term>

        <listitem>
          <para>Permite consultar metadatos de nuestra aplicación.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>org.springframework.roo.metadata.MetadataDependencyRegistry</term>

        <listitem>
          <para>Gestiona las dependencias entre metadatos.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>org.springframework.roo.project.ProjectOperations</term>

        <listitem>
          <para>Operaciones para la gestión del proyecto.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>

  <section xml:id="recetas_manejo-ficheros-xml">
    <title>Ficheros XML</title>

    <para>La clase
    <classname>org.springframework.roo.support.util.XmlUtils</classname> tiene
    herramientas básica para la lectura, búsqueda, creación y modificación de
    fichero XML. Entre sus métodos encontramos:</para>

    <itemizedlist>
      <listitem>
        <para><methodname>getDocumentBuilder</methodname></para>
      </listitem>

      <listitem>
        <para><methodname>writeXml</methodname></para>
      </listitem>

      <listitem>
        <para><methodname>findElements</methodname></para>
      </listitem>
    </itemizedlist>

    <para>Aquí hay una serie de recetas para el manejo de este tipo de
    ficheros.</para>

    <section xml:id="recetas_manejo-ficheros-xml_crear">
      <title>Crear un fichero XML</title>

      <para>Este ejemplo crea un fichero <filename>cxf-servlet.xml</filename>
      dentro del directorio <filename>WEB-INF</filename> de la
      aplicación:</para>

      <programlisting>    //Ruta relativa 
    String xmlPath =pathResolver.getIdentifier(Path.SRC_MAIN_WEBAPP, "WEB-INF/cxf-servlet.xml");

    Document xml;
    MutableFile mutableFile= fileManager.createFile(xmlPath);

    Element root = xml.createElement("root");
        
    Element child1 = xml.createElement("child1");
    child1.setNodeValue("nodo 1");
    root.appendChild(child1);

    Element child2 = xml.createElement("child2");
    child2.setAttribute("attr", "hola");

    Element child3 = xml.createElement("child3");
    child3.setNodeValue("nodo 3");

    child2.appendChild(child3);
    root.appendChild(child2);
        
        
    xml.appendChild(root);


    // Write file
    XmlUtils.writeXml(mutableFile.getOutputStream(), xml);

    fileManager.scan();</programlisting>
    </section>

    <section xml:id="recetas_manejo-ficheros-xml_añadir-dtd">
      <title>Añadir DTD a un XML</title>

      <para>Al utilizar el método <command>XmlUtils.writeXml(OutpuStream,
      Xml)</command> en un xml con DTD elimina el DTD al actualizarlo o si
      definimos uno cuando creamos un archivo xml.</para>

      <para>Para evitar este problema se ha de crear un Transformer con los
      datos necesarios de nuestro DTD:</para>

      <programlisting>    final static String DOCTYPE_PUBLIC = "-//Apache Software Foundation//DTD Tiles Configuration 2.1//EN";
    final static String DOCTYPE_SYSTEM = "http://tiles.apache.org/dtds/tiles-config_2_1.dtd";</programlisting>

      <para>Crear un Transformer para llamar al método sobrecargado que
      contiene el parámetro del tipo <emphasis>transformer</emphasis> y así
      definir la gramática del xml:</para>

      <programlisting>   // Define DTD
   Transformer xformer;
   try {
       xformer = XmlUtils.createIndentingTransformer();
   } catch (Exception ex) {
       throw new IllegalStateException(ex);
   }

   xformer.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, DOCTYPE_PUBLIC);
   xformer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, DOCTYPE_SYSTEM);
   
   XmlUtils.writeXml(xformer, webXmlMutableFileDestination.getOutputStream(), webXmlDestination);</programlisting>
    </section>

    <section xml:id="recetas_manejo-ficheros-xml_crear-a-partir-plantilla">
      <title>Crear un XML a partir de una plantilla</title>

      <para>El siguiente ejemplo crea un fichero
      <filename>cxf-servlet.xml</filename> dentro del directorio
      <filename>WEB-INF</filename> de la aplicación a partir de una plantilla
      que hayamos incluido en los recursos del add-on:</para>

      <programlisting>    //Ruta relativa 
    String xmlPath =pathResolver.getIdentifier(Path.SRC_MAIN_WEBAPP, "WEB-INF/cxf-servlet.xml");

    Document xml;
    MutableFile mutableFile= fileManager.createFile(xmlPath);
    InputStream templateInputStream = TemplateUtils.getTemplate(getClass(), "cxf-servlet-template.xml");
    try {
            xml = XmlUtils.getDocumentBuilder().parse(templateInputStream);
    } catch (Exception ex) {
            throw new IllegalStateException(ex);
    }

    // Write file
    XmlUtils.writeXml(mutableFile.getOutputStream(), xml);

    fileManager.scan();</programlisting>
    </section>

    <section xml:id="recetas_manejo-ficheros-xml_actualizar-elemento">
      <title>Realizar cambios en XML con posibilidad de deshacer</title>

      <para>Este ejemplo se busca dentro del fichero
      <filename>webmvc-config.xml</filename> el bean del tema por defecto y lo
      cambia el ID del tema actual:</para>

      <programlisting>  /**
   * Get and initialize the absolute path for {@code webmvc-config.xml}.
   * 
   * @return the absolute path to the file (never null)
   */
  public String getMvcConfigFile() {

    // resolve absolute path for menu.jspx if it hasn't been resolved yet
    return getPathResolver().getIdentifier(Path.SRC_MAIN_WEBAPP,
          "/WEB-INF/spring/webmvc-config.xml");
  }

  /**
   * Open WEB-INF/spring/webmvc-config.xml file and set the default theme
   * to given theme Id.
   * &lt;p&gt;
   * {@link FileManager} is used for safe update.
   * 
   * @param id
   */
  private void updateDefaultTheme(String themeId) {

    String webMvc = getMvcConfigFile();
    MutableFile mutableConfigXml = null;
    Document webConfigDoc;

    try {
      if (fileManager.exists(webMvc)) {
        mutableConfigXml = fileManager.updateFile(webMvc);
        webConfigDoc = org.springframework.roo.support.util.XmlUtils
            .getDocumentBuilder().parse(mutableConfigXml.getInputStream());
      }
      else {
        throw new IllegalStateException("Could not acquire ".concat(webMvc));
      }
    }
    catch (Exception e) {
      throw new IllegalStateException(e);
    }

    // Get themeResolver bean to change default theme
    Element resolverElement = org.springframework.roo.support.util.XmlUtils
        .findFirstElement("//*[@id='themeResolver']",
            (Element) webConfigDoc.getFirstChild());

    // throw exception if themeResolver doesn't exist
    Assert.notNull(resolverElement,
        "Could not find bean 'themeResolver' in ".concat(webMvc));

    resolverElement.setAttribute("p:defaultThemeName", themeId);

    org.springframework.roo.support.util.XmlUtils.writeXml(
        mutableConfigXml.getOutputStream(), webConfigDoc);
  }</programlisting>
    </section>
  </section>

  <section xml:id="recetas_añadir-dependencia">
    <title>Dependencias del proyecto</title>

    <section>
      <title>Añadir dependencias y propiedades al proyecto</title>

      <para>En este ejemplo veremos cómo añadir dependencias y propiedades al
      proyecto a partir del fichero configuration.xml ubicado dentro de los
      recursos del add-on, SRC_MAIN_RESOURCES/PACKAGE/.</para>

      <para>El fichero de definición puede ser como este:</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;configuration&gt;
  &lt;gvnix&gt;
    &lt;web-menu&gt;
      &lt;dependencies&gt;
        &lt;cxf&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
        &lt;artifactId&gt;cxf-api&lt;/artifactId&gt;
        &lt;version&gt;2.1.3&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
        &lt;artifactId&gt;cxf-rt-frontend-jaxws&lt;/artifactId&gt;
        &lt;version&gt;2.1.3&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
        &lt;artifactId&gt;cxf-rt-transports-http&lt;/artifactId&gt;
        &lt;version&gt;2.1.3&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;
        &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;
        &lt;version&gt;2.1&lt;/version&gt;
      &lt;/dependency&gt;
        &lt;/cxf&gt;
      &lt;/dependencies&gt;
      &lt;properties&gt;
        &lt;gvnix.version&gt;${project.version}&lt;/gvnix.version&gt;
      &lt;/properties&gt;
    &lt;/web-menu&gt;
  &lt;/gvnix&gt;
&lt;/configuration&gt;
</programlisting>

      <para>El siguiente código añade las dependencias al proyecto:</para>

      <programlisting>  /** {@inheritDoc} */
  public void setup() {
    // Parse the configuration.xml file
    Element configuration = XmlUtils.getConfiguration(getClass());

    // Add POM properties
    updatePomProperties(configuration);

    // Add dependencies to POM
    updateDependencies(configuration);

    // ...
  }

  /**
   * Install properties defined in external XML file
   * @param configuration
   */
  private void updatePomProperties(Element configuration) {
    List&lt;Element&gt; addonProperties = XmlUtils.findElements(
        "/configuration/gvnix/web-menu/properties/*", configuration);
    for (Element property : addonProperties) {
      projectOperations.addProperty(new Property(property));
    }
  }

  /**
   * Install dependencies defined in external XML file
   * @param configuration
   */
  private void updateDependencies(Element configuration) {
    List&lt;Dependency&gt; dependencies = new ArrayList&lt;Dependency&gt;();
    List&lt;Element&gt; securityDependencies = XmlUtils.findElements(
        "/configuration/gvnix/web-menu/dependencies/dependency", configuration);
    for (Element dependencyElement : securityDependencies) {
      dependencies.add(new Dependency(dependencyElement));
    }
    projectOperations.addDependencies(dependencies);
  }
</programlisting>
    </section>

    <section>
      <title>Comprobar si existe una dependencia</title>

      <para>En este trozo de código investiga si el proyecto ya incluye una
      dependencia con una librería en concreto, comprobando también si existe
      pero con versión distinta:</para>

      <programlisting>  /** {@inheritDoc} */
  public boolean isSpringSecurityInstalled() {

    if(!isProjectAvailable()) {
      // no project available yet, we cannot check for SS
      return false;
    }

    ProjectMetadata projectMetadata = getProjectMetadata();

    // create Spring Security dependency entity
    Dependency dep = new Dependency("org.springframework.security",
        "spring-security-core", "3.0.5.RELEASE");

    // locate Spring Security dependency
    Set&lt;Dependency&gt; dependencies = projectMetadata
        .getDependenciesExcludingVersion(dep);

    // if didn't find, Spring Security is not installed
    if (dependencies.isEmpty()) {
      return false;
    }
    return true;
  }
</programlisting>
    </section>

    <section>
      <title>Actualización de versiones de dependencias</title>

      <para>Hemos visto como añadir propiedades y dependencias al archivo
      <emphasis>pom.xml</emphasis> del proyecto. Por lo general, es
      interesante que si una nueva versión de gvNIX hace uso de versiones más
      nuevas de librerías de terceros, se actualice las partes necesarias del
      <emphasis>pom.xml</emphasis> del proyecto para favorecernos de las
      mejoras que puedan aportar. Spring Roo ya lo hace eactualizando la
      proiedad <emphasis>&lt;roo.version/&gt;</emphasis> cada vez que liberan
      una nueva versión del framework.</para>

      <note>
        <para>Es posible que, en función de donde queramos usar el código
        siguiente, necesitemos modificarlo para que se adapte a las
        necesidades particulares del addón donde lo usamos.</para>
      </note>

      <para>Para poder contemplar esta funcionalidad necesitmos el siguiente
      código:</para>

      <programlisting>public enum Qualifiers {

    RELEASE("RELEASE"), EMPTY(""), SNAPSHOT("SNAPSHOT");

    private String qualifier;

    private Qualifiers(String qualifier) {
        this.qualifier = qualifier;
    }

    public boolean isRelease() {
        return this.equals(RELEASE) || this.equals(EMPTY);
    }

    public boolean isSnapshot() {
        return this.equals(SNAPSHOT);
    }

    /**
     * Says if the qualifier is newer than passed qualifier
     * &lt;ul&gt;
     * &lt;li&gt;RELEASE equals to EMPTY&lt;/li&gt;
     * &lt;li&gt;RELEASE newer than SNAPSHOT&lt;/li&gt;
     * &lt;/ul&gt;
     * 
     * @param q
     * @return &lt;ul&gt;
     *         &lt;li&gt;0 if this equals to q&lt;/li&gt;
     *         &lt;li&gt;1 if this newer than q&lt;/li&gt;
     *         &lt;li&gt;-1 otherwise&lt;/li&gt;
     *         &lt;/ul&gt;
     */
    public int newerThan(Qualifiers q) {
        if (this.equals(q)) {
            return 0;
        }
        if (this.isRelease() &amp;&amp; q.isSnapshot()) {
            return 1;
        }
        return -1;
    }
}</programlisting>

      <para>El enumerado <emphasis>Qualifiers</emphasis> sirve para poder
      decidir de entre dos versiones iguales cual es más nueva basado en su
      cualificador (ej.: X.Y.Z &gt; X.Y.Z-SNAPSHOT. La ausencia de
      cualificador indica que es una versión RELEASE).</para>

      <programlisting xml:id="recetas-actualizacion_versiones-VersionInfo">public class VersionInfo {
    private Integer major = 0;
    private Integer minor = 0;
    private Integer patch = 0;
    private Qualifiers qualifier = Qualifiers.EMPTY;

    public int compareTo(VersionInfo v) {
        if (v == null) {
            throw new NullPointerException();
        }
        int result = major.compareTo(v.major);
        if (result != 0) {
            return result;
        }
        result = minor.compareTo(v.minor);
        if (result != 0) {
            return result;
        }
        result = patch.compareTo(v.patch);
        if (result != 0) {
            return result;
        }
        result = qualifier.newerThan(v.qualifier);
        if (result != 0) {
            return result;
        }
        return 0;
    }

    @Override
    public String toString() {
        return major + "." + minor + "." + patch + "." + qualifier;
    }

    /**
     * Extracts the version information from the string. Never throws an
     * exception. &lt;br/&gt;
     *
     * @param version
     *            to extract from (can be null or empty)
     * @return the version information or null if it was not in a normal form
     */
    public static VersionInfo extractVersionInfoFromString(String version) {
        if (version == null || version.length() == 0) {
            return null;
        }

        String[] ver = version.split("\\.");
        try {
            // versions as x.y.z
            if (ver.length == 3) {
                VersionInfo result = new VersionInfo();
                result.major = new Integer(ver[0]);
                result.minor = new Integer(ver[1]);
                // gvNIX versions can be x.y.z (for final versions or release
                // versions) and x.y.z-q (for snapshots versions)
                String[] patchVerQualifier = ver[2].split("-");
                result.patch = new Integer(patchVerQualifier[0]);
                if (patchVerQualifier.length == 2) {
                    String qualifier = patchVerQualifier[1];
                    if (qualifier.equalsIgnoreCase(Qualifiers.RELEASE
                            .toString())) {
                        result.qualifier = Qualifiers.RELEASE;
                    } else if (qualifier.equalsIgnoreCase(Qualifiers.SNAPSHOT
                            .toString())) {
                        result.qualifier = Qualifiers.SNAPSHOT;
                    }
                }
                return result;
            }
            // versions as x.y
            if (ver.length == 2) {
                VersionInfo result = new VersionInfo();
                result.major = new Integer(ver[0]);
                result.minor = new Integer(ver[1]);
                return result;
            }
        } catch (RuntimeException e) {
            return null;
        }
        return null;
    }
}</programlisting>

      <para>VersionInfo es la clase que permite decidir que versión es mayor
      de entre dos. Realmente permite crear un objeto basándonos en una caden
      que informa de un número de versión (según las recomendaciones Maven),
      esto es, <emphasis>X.Y.Z-QUALIFIER (donde X=Versión mayor, Y=Version
      menor, Z=Versión del patch y
      QUALIFIER=[RELEASE|SNAPSHOT|...].</emphasis> La implementación del
      método <emphasis role="bold">comparteTo(...)</emphasis> permite esta
      operación.</para>

      <para>Finalmente una clase de utilidad que nos permite manipular el
      pom.xml del proyecto para usando las clases anteriores:</para>

      <programlisting>public class DependenciesVersionManager {
    private static final String PROJECT_METADATA_IDENTIFIER = ProjectMetadata
            .getProjectIdentifier();

    /**
     * Given a list of DOM elements representing Maven dependencies determines
     * if may add or not them to project's pom.xml
     * 
     * @param metadataService
     * @param projectOperations
     * @param dependenciesElements
     * @return true if a dependency has been added or updated, false otherwise
     */
    <emphasis role="bold">public static boolean manageDependencyVersion</emphasis>(
            MetadataService metadataService,
            ProjectOperations projectOperations,
            List&lt;Element&gt; dependenciesElements) {
        // Get project metadata in order to check existing properties
        ProjectMetadata md = (ProjectMetadata) metadataService
                .get(PROJECT_METADATA_IDENTIFIER);
        if (md == null) {
            return false;
        }

        boolean updateDependency = true;
        Set&lt;Dependency&gt; results;
        Dependency dependency = null;
        for (Element depen : dependenciesElements) {
            dependency = new Dependency(depen);
            // Get existing dependencies for check them against new dependencies
            results = md.getDependenciesExcludingVersion(dependency);

            VersionInfo existingDepVersionInfo = null;
            VersionInfo newDepVersionInfo = VersionInfo
                    .extractVersionInfoFromString(dependency.getVersionId());

            for (Dependency existingDependency : results) {
                existingDepVersionInfo = VersionInfo
                        .extractVersionInfoFromString(existingDependency
                                .getVersionId());
                if (existingDepVersionInfo != null) {
                    // Remove existing dependency in pom.xml just if it's older
                    // than the new one
                    if (existingDepVersionInfo.compareTo(newDepVersionInfo) &lt; 0) {
                        projectOperations.removeDependency(existingDependency);
                        updateDependency = true;
                    } else {
                        updateDependency = false;
                    }
                }
            }
        }
        // Add the new dependency just if needed
        if (updateDependency) {
            projectOperations.addDependency(dependency);
        }
        return updateDependency;
    }

    /**
     * Given a list of DOM elements representing Maven properties determines if
     * may add or not them to project's pom.xml
     * 
     * @param metadataService
     * @param projectOperations
     * @param projectProperties
     * @return true if a property has been added or updated, false otherwise
     */
    <emphasis role="bold">public static boolean managePropertyVersion</emphasis>(
            MetadataService metadataService,
            ProjectOperations projectOperations, List&lt;Element&gt; projectProperties) {

        boolean propertiesUpdated = false;

        // Get project metadata in order to check existing properties
        ProjectMetadata md = (ProjectMetadata) metadataService
                .get(PROJECT_METADATA_IDENTIFIER);
        if (md == null) {
            return propertiesUpdated;
        }

        Set&lt;Property&gt; results = null;
        Property property = null;
        VersionInfo existingPropVersionInfo = null;
        VersionInfo newPropVersionInfo = null;
        for (Element elemProperty : projectProperties) {
            propertiesUpdated = true;
            // Create a new property instance for the property in add-on config
            property = new Property(elemProperty);
            newPropVersionInfo = VersionInfo
                    .extractVersionInfoFromString(property.getValue());
            // Get existing properties for check them against new properties
            results = md.getPropertiesExcludingValue(property);
            for (Property existingProperty : results) {
                existingPropVersionInfo = VersionInfo
                        .extractVersionInfoFromString(existingProperty
                                .getValue());
                if (existingPropVersionInfo != null) {
                    // Remove existing property in pom.xml just if it's older
                    // than the new one
                    if (existingPropVersionInfo.compareTo(newPropVersionInfo) &lt; 0) {
                        // We don't need to remove the property since it's
                        // defined and addProperty will replace it, so, just
                        // mark is as updatable
                        // projectOperations.removeProperty(property);
                        propertiesUpdated = true;
                    } else {
                        propertiesUpdated = false;
                    }
                }
            }
            // Add the new property just if needed
            if (propertiesUpdated) {
                projectOperations.addProperty(new Property(elemProperty));
            }
        }
        return propertiesUpdated;
    }

}</programlisting>

      <para>Los métodos <emphasis
      role="bold">manageDependencyVersion</emphasis> y <emphasis
      role="bold">managePropertyVersion</emphasis> se ocupan de buscar entre
      las dependencias (y propiedades) ya configuradas del proyecto en el
      pom.xml una dependencia o una propiedad determinada y sirviendose del
      objeto <link
      linkend="recetas-actualizacion_versiones-VersionInfo">VersionInfo</link>
      decidir que hacer con la nueva dependencia / propiedad que se desea
      saber si hay que añadir al descriptor del proyecto.</para>

      <para>La búsqueda de dependencias / propiedades definidas en el proyecto
      se hace mediante los métodos:</para>

      <programlisting>ProjectMetadata#getDependenciesExcludingVersion(dependency)
y
ProjectMetadata#getPropertiesExcludingValue(property)</programlisting>

      <para>Estos métodos ofrecen la búsqueda de dependencias y propiedades en
      el descriptor del proyecto sin hacer caso al número de versión (o valor
      en el caso de las propiedades). En caso de que exista la dependencia o
      propiedad buscada debemos decidir si la actualizamos o la dejamos tal
      cual está definida. Para ello nos valemos de VersionInfo. En caso de
      querer actualizar una versión de una dependencia, primero debemos
      eliminar la descripción de la misma en el pom.xml
      (<emphasis>ProjectOperations#removeDependency(dependency)</emphasis>) y
      luego añadir la nueva
      (<emphasis>ProjectOperations#addDependency(dependency)</emphasis>). En
      el caso de las propiedades no es necesario eliminar la definición
      existente ya que el método
      <emphasis>ProjectOperations#addProperty(property)</emphasis> modificará
      el valor de la propiedad por el nuevo.</para>

      <important>
        <para><emphasis role="bold">En gvNIX se ha tomado la decisión de que
        han de prevalecer las versiones mayores de las dependencias
        definidas</emphasis>. Esto quiere decir que si una versión de gvNIX
        actualiza la versión de una dependencía a una versión mayor (incluida
        la versión de la propia dependencía con un add-on en el caso del uso
        de anotaciones definidas por la librería del add-on), aunque
        posteriormente el proyecto se gestione con una versión de gvNIX
        anterior (abrimos una versión previa de gvNIX en el directorio del
        proyecto con el que se está trabajando) la versión que prevalecerá
        será la más nueva. Ejemplo:</para>

        <orderedlist>
          <listitem>
            <para>Creamos un proyecto con gvNIX.</para>
          </listitem>

          <listitem>
            <para>Este proyecto hace uso del add-on Service en una versión
            antigua.</para>
          </listitem>

          <listitem>
            <para>Actualizamos gvNIX a una versión posterior y abrimos el
            mismo proyecto con esta nueva versión de gvNIX. Entonces la
            dependencia con el add-on Service se actualizará a la nueva
            versión (casi seguramente).</para>
          </listitem>

          <listitem>
            <para>Volvemos a abrir con un gvNIX antiguo sobre el proyecto. La
            dependencia con el add-on Service debe permanecer con la versión
            más nueva.</para>
          </listitem>
        </orderedlist>

        <para>La misma decisión es aplicable a librerías de terceros
        (JasperReports, CXF, Axis, ...)</para>
      </important>
    </section>
  </section>

  <section>
    <title>Metadatos del proyecto</title>

    <para>Acceso a los metadatos del proyecto desde el metodo
    <emphasis>activate</emphasis> de un componente OSGi.</para>

    <programlistingco>
      <areaspec>
        <area coords="???" xml:id="recetas-metadatos_proyecto"/>
      </areaspec>

      <programlisting>public class PageOperationsImpl implements PageOperations {

  /**
   * Use ProjectMetadataProvider to access project metadata.
   */
  @Reference private ProjectMetadataProvider projectMetadataProvider;

  /**
   * Utility to get {@link ProjectMetadata}.
   * &lt;p&gt;
   * This method will thrown if unavailable project metadata.
   *  
   * @return ProjectMetadata or null if project isn't available yet
   */
  private ProjectMetadata getProjectMetadata() {
    return (ProjectMetadata) projectMetadataProvider.get(ProjectMetadata.getProjectIdentifier());    
  }
}
</programlisting>
    </programlistingco>
  </section>

  <section xml:id="recetas_crear-listener-filesystem">
    <title>Crear listeners del filesystem</title>

    <para>En la mayoría de casos no usaremos este tipo de listeners ya que
    normalmente dependeremos de los metadatos.</para>

    <para>Para solicitar notificaciones del filesystem debemos de crear una
    clase que implemente <classname>FileEventListener</classname>.</para>

    <para>Se añaden las anotaciones <classname>@Component</classname> y
    <classname>@Service</classname> a la clase para que el
    <classname>FileMonitorService</classname> de Roo lo detecte
    automáticamente. Para ver más sobre esto leer <link
    linkend="creacion-addon_osgi">declaración y uso de componente-servicios
    OSGi</link>.</para>

    <para>El servicio <emphasis>no monitoriza todos los ficheros</emphasis> de
    base. Puede ser necesario registrar los recursos que deseamos monitorizar
    (aunque por defecto ya pueden estar los que necesitamos). Esto se maneja
    desde el la clase que implementa la interfaz
    <classname>FileMonitorService</classname>:
    <classname>NotifiableFileMonitorService</classname>.</para>

    <para>Este ejemplo muestra un mensaje de <emphasis>log</emphasis> de cada
    cambio producido en los recursos monitorizados:</para>

    <programlisting>  @Component
  @Service
  public class LogFiles implements FileEventListener {
        
       private static Logger logger = Logger.getLogger(LogFiles.class.getName());
                                
       public void onFileEvent(FileEvent fileEvent) {
           logger.warning(fileEvent.getOperation().name()+":"+fileEvent.getFileDetails().getCanonicalPath());
       }
  }</programlisting>
  </section>

  <section xml:id="recetas_crear-listener-metadatos">
    <title>Crear listener de metadatos</title>

    <para>Este es un ejemplo sencillo de implementación de listener de
    metadatos.</para>

    <para>La clase de listener debe implementar la interfaz
    <classname>MetadataNotificationListener</classname> y se añaden las
    anotaciones <classname>@Component</classname> y
    <classname>@Service</classname> a la clase para que el
    <classname>MetadataDependencyRegistry</classname> la inyecte
    automáticamente al ser un módulo OSGI que implementa
    <classname>MetadataNotificationListener</classname>.</para>

    <para>En este ejemplo crearemos un listener que muestra información sobre
    los eventos recibidos de clase java. Si, además es una entidad muestra sus
    métodos:</para>

    <programlisting>@Component
@Service
public class JavaClassMetadataListener implements MetadataNotificationListener {

   private static Logger logger = Logger.getLogger(JavaClassMetadataListener.class.getName());

   private static final String javaClassMetadataType = MetadataIdentificationUtils.getMetadataClass(PhysicalTypeIdentifier.getMetadataIdentiferType());

   @Reference
   private MetadataDependencyRegistry metadataDependencyRegistry;

   @Reference
   private MetadataService metadataService;

   public void notify(String upstreamDependency, String downstreamDependency) {

     if (!javaClassMetadataType.equals(MetadataIdentificationUtils.getMetadataClass(upstreamDependency))){
       // NO es la notificación del metadato de tipo "clase java"
      return;
     }
     logger.warning("---------------------------------------------");
     PhysicalTypeMetadata physicalTypeMetadata = (PhysicalTypeMetadata) metadataService.get(upstreamDependency);

     PhysicalTypeDetails details = physicalTypeMetadata.getPhysicalTypeDetails();

     JavaType javaType = details.getName();
     Path path = PhysicalTypeIdentifierNamingUtils.getPath(javaClassMetadataType, upstreamDependency);

     logger.warning("Notificación de la clase: "+ javaType.getSimpleTypeName());

     EntityMetadata entityMetadata = (EntityMetadata) metadataService.get(EntityMetadata.createIdentifier(javaType, path));
     if (entityMetadata == null){
        logger.warning("\tNo es entiedad");
     } else {
        logger.warning("\tmetodos: ");
        for (MethodMetadata method : entityMetadata.getItdTypeDetails().getDeclaredMethods()){
          logger.warning("\t\t"+method.getMethodName());
        }
     }
     logger.warning("---------------------------------------------");
  }
}</programlisting>
  </section>

  <section xml:id="recetas_copia-directorios-recursiva">
    <title>Copiar directorios recursivamente</title>

    <para>TBC: Desactualizado. Actualizar con lo desarrollado en add-web-theme
    de gvNIX 0.6</para>

    <para>Ejemplo sencillo para la copia de un directorio de forma recursiva
    dentro del proyecto específico.</para>

    <para>Se utiliza el componente <classname>FileManager</classname> para la
    gestión de archivos para tener el soporte de deshacer la acción ante un
    error.</para>

    <para>Este método se llama a si mismo recursivamente para los directorios
    y para los fichero delega en un método
    <methodname>fileCopyToProject</methodname> que definido más abajo:</para>

    <programlisting>    private boolean copyRecursively(File source, File destination, boolean deleteDestinationOnExit) {
    
      Assert.notNull(source, "Source directory required");
      Assert.notNull(destination, "Destination directory required");
      Assert.isTrue(source.exists(), "Source directory '" + source + "' must exist");
      Assert.isTrue(source.isDirectory(), "Source directory '" + source + "' must be a directory");
      if (destination.exists()) {
          Assert.isTrue(destination.isDirectory(), "Destination directory '"
            + destination + "' must be a directory");
      } else {
          destination.mkdirs();
          if (deleteDestinationOnExit) {
            destination.deleteOnExit();
          }
      }
      for (File s : source.listFiles()) {
          File d = new File(destination, s.getName());
          if (deleteDestinationOnExit) {
            d.deleteOnExit();
          }
          if (s.isFile()) {
            fileCopyToProject(s, d);
          } else {
            // It's a sub-directory, so copy it
            d.mkdir();
            if (!copyRecursively(s, d, deleteDestinationOnExit)) {
                return false;
            }
          }
      }
      return true;
    }</programlisting>

    <para>El método <methodname>fileCopyToProject</methodname> copia un
    archivo utilizando el servicio <classname>FileManager</classname> mediante
    del archivo origen al destino:</para>

    <programlisting>
   private void fileCopyToProject(File source, File destination) {
      MutableFile mutableFile;
      byte[] template;

      InputStream templateInputStream;
      InputStreamReader readerFile;

      try {

        templateInputStream = new FileInputStream(source);

        readerFile = new InputStreamReader(templateInputStream);

        template = FileCopyUtils.copyToByteArray(templateInputStream);

      } catch (IOException ioe) {
        throw new IllegalStateException("Unable load ITD css template", ioe);
      }

      if (!fileManager.exists(destination.getAbsolutePath())) {
        mutableFile = fileManager.createFile(destination.getAbsolutePath());
        Assert.notNull(mutableFile, "Could not create ITD file '"
            + destination.getAbsolutePath() + "'");
      } else {
        mutableFile = fileManager.updateFile(destination.getAbsolutePath());
      }

      try {

        FileCopyUtils.copy(template, mutableFile.getOutputStream());
      } catch (IOException ioe) {
        throw new IllegalStateException("Could not output '"
            + mutableFile.getCanonicalPath() + "'", ioe);
      }
   }</programlisting>
  </section>

  <section xml:id="recetas_monitorizacion-directorios-no-registrados">
    <title>Monitorización de directorios no registrados</title>

    <para>En este ejemplo necesitamos monitorizar los cambios en un directorio
    que no está registrado para monitorizar en la configuración por defecto
    del framework.</para>

    <para>Para habilitar la monitorización del directorio debemos registrar un
    instancia de <classname>DirectoryMonitoringRequest</classname> en el
    servicio <classname>NotifiableFileMonitorService</classname>:</para>

    <programlisting>   @Reference
   private NotifiableFileMonitorService fileMonitorService;
   .
   .
   .
        DirectoryMonitoringRequest directoryMonitoringRequest = new DirectoryMonitoringRequest(
        new File("./myDir"), true, (MonitoringRequest
          .getInitialMonitoringRequest("./myDir"))
          .getNotifyOn());

        fileMonitorService.add(directoryMonitoringRequest);
        fileMonitorService.scanAll();</programlisting>

    <para>En la llamada al
    <methodname>fileMonitorService.scanAll()</methodname> ya comenzará las
    notificaciones de este directorio.</para>
  </section>

  <section xml:base="recetas_crear-clase-desde-codigo">
    <title>Crear una clase java desde código</title>

    <para><emphasis>[Hay que revisar el código]</emphasis></para>

    <para>En este ejemplo creamos una clase Java usando código Java. En este
    caso estamos generando una clase que implementa un interface, rellenando
    su método:</para>

    <programlisting>  private void generateJavaFile(JavaType initializerClass) {
      String ressourceIdentifier = classpathOperations.getPhysicalLocationCanonicalPath(
              initializerClass, Path.SRC_MAIN_JAVA);
      String declaredByMetadataId = PhysicalTypeIdentifier.createIdentifier(initializerClass, 
              pathResolver.getPath(ressourceIdentifier));

      List&lt;MethodMetadata&gt; declaredMethods = new ArrayList&lt;MethodMetadata&gt;(1);

      InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();
      bodyBuilder.appendFormalLine(
             "binder.registerCustomEditor(java.lang.String.class, new org.springframework.beans.propertyeditors.StringTrimmerEditor(true);");

      // Params
      List&lt;JavaType&gt; params = new ArrayList&lt;JavaType&gt;(2);
      params.add(new JavaType("org.springframework.web.bind.WebDataBinder"));
      params.add(new JavaType("org.springframework.web.context.request.WebRequest"));

      // Params Names
      List&lt;JavaSymbolName&gt; paramNames = new ArrayList&lt;JavaSymbolName&gt;(2);
      paramNames.add(new JavaSymbolName("binder"));
      paramNames.add(new JavaSymbolName("request"));


      //Annotations
      List&lt;AnnotationMetadata&gt; annotations = new ArrayList&lt;AnnotationMetadata&gt;(1);
      annotations.add(new DefaultAnnotationMetadata(new JavaType(Override.class.getName()), null));

      declaredMethods.add(new DefaultMethodMetadata(
             declaredByMetadataId,
             Modifier.PUBLIC,
             new JavaSymbolName("initBinder"),
             null,
             AnnotatedJavaType.convertFromJavaTypes(params),
             paramNames,
             annotations,
             null,
             body)
        );


      List&lt;JavaType&gt; implementsTypes = new ArrayList&lt;JavaType&gt;();
      implementsTypes.add( new JavaType("org.springframework.web.bind.support.WebBindingInitializer"));


      ClassOrInterfaceTypeDetails details = new DefaultClassOrInterfaceTypeDetails(
             declaredByMetadataId,
             initializerClass,
             Modifier.PUBLIC,
             PhysicalTypeCategory.CLASS,
             null,null,declaredMethods,null,null,implementsTypes,null,null
             );

      classpathOperations.generateClassFile(details);

  }</programlisting>
  </section>

  <section xml:id="recetas_alterar-comportamiento-metodo">
    <title>Alterar comportamiento de métodos existentes</title>

    <para>La librería <emphasis>AspectJ</emphasis> permite, dentro de un
    fichero <filename>.aj</filename>, añadir anotaciones a método de la clase
    a que ser asocia. Esto <emphasis>no está limitado a los métodos que
    definimos en nuestro fichero o a los método declarados en el
    .java</emphasis>, también podemos añadir anotaciones a métodos definidos
    en otros .<filename>aj</filename> que no hayamos definido nosotros.</para>

    <para>La información está recogida de este mensaje en el foro: <link
    xlink:href="http://forum.springsource.org/showpost.php?p=286967&amp;postcount=3">http://forum.springsource.org/showpost.php?p=286967&amp;postcount=3</link></para>
  </section>

  <section xml:id="recetas_generar-codigo-aj-inexistente-java">
    <title>Comprobar existencia en Java antes de generar en AJ</title>

    <para>A la hora de generar código en un AJ hay que comprobar si ya existe
    en el Java. Si se intenta crear en el AJ un método, anotación, etc. y ya
    existe en Java se producirán comportamientos inesperados que puede que no
    sean fáciles de resolver si no es debugando la clase Metadata para
    detectar la excepción que se produce.</para>
  </section>

  <section>
    <title>Generar tests funcionales de Selenium</title>

    <para>http://projects.disid.com/issues/5823</para>

    <para>org.springframework.roo.addon.web.selenium.SeleniumOperationsImpl</para>
  </section>
  
  <section>
    <title>No se añade un elemento en Java o AJ</title>

    <para>Si no se añade alguna propiedad, método, etc. 
    a un fichero Java o AJ puede ser debido a que dicho elemento
    no está asociado al metadataId adecuado.</para>

  </section>
  
  <section>
    <title>No se añade un elemento en Java o AJ</title>

    <para>Si no se añade alguna propiedad, método, etc. 
    a un fichero Java o AJ puede ser debido a que dicho elemento
    no está asociado al metadataId adecuado.</para>

  </section>
  
  <section>
  	<title>Múltiples modificaciones mismo fichero</title>
  	
  	<para>Si se producen múltiples modificaciones sucesivas de un
  	mismo fichero en la consola al ejecutar un comando, puede evitarse
  	cambiando a false la variable writeImmediately de los métodos del
  	fileManager.</para>
  </section>
  
  <section>
  	<title>Utilidades XML</title>
  	
  	<para>Existen ahora código de Roo que facilita la escritura de
  	algunos archivos como, por ejemplo, XML (xmlRoundTripFileManager)
  	y que puede que haya implementaciones propias de gvNIX que hacen
  	prácticamente los mismo.</para>
  </section>
  
  <section>
  	<title>Evitar parseado XML en metadatas y listeners</title>
  	
  	<para>Tal y como se ha detectado en #5800, los metadata y
  	listeners se ejecutan gran cantidad de veces, principalmente en
  	el arranque de la consola. Esto sucede en los addons de gvNIX y
  	también en los de Roo.</para>

	<para>Es por ello, que no se deben hacer operaciones computacionalmente
	muy costosas como, por ejemplo, parseado de XMLs. Un caso habitual
	de este tipo son los setup que suelen existir en todos los addons
	que se encargan de añadir dependencias, propiedades, plugins, etc.
	en el pom.xml o en otros ficheros de configuración como web.xml,
	webmvc-config.xml, etc.</para>

	<para>La recomendación a partir de ahora es que los setup solo se
	realicen desde los comandos y nunca desde los metadata o listeners.</para>
  </section>
  
  <section>
  	<title>Clases OSGi con anotación @Service y/o @Component</title>
  	
  	<para>Cuando anotamos una clase con @Service y/o @Component estamos
  	definiendo una clase servidor, es decir todos sus atributos de clase
  	tienen valor durante toda la vida de la clase.</para>

	<para>Hay que tener mucho cuidado con la lógica que actúa sobre atributos:
	Si el atributo es otro servicio o componente no habrá mayor problema.
	Si el atributo es interno (no es componente), se inicializa en una petición
	y en sucesivas peticiones se ejecuta lógica sobre ese atributo.
	En estos casos podría producirse errores si el atributo no se reinicializa
	adecuadamente. Para estas situaciones sería interesante trabajar como si
	fuera un entorno web: cada petición debe obtener todo lo necesario para una
	respuesta correcta.</para>
  </section>
  
  <section>
  	<title>Remove all @Reference PathResolver</title>
  	
  	<para>Remove all @Reference PathResolver declarations from classes
  	and retrieve PathResolver from ProjectMetadata instead.
  	https://jira.springsource.org/browse/ROO-2097.</para>
  </section>

</chapter>
